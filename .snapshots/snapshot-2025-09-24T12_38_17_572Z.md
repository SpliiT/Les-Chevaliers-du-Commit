Enter your prompt here

# Project Files

- c:\Users\rexma\Desktop\Les Chevalier du commit\Les-Chevaliers-du-Commit\labyrinthe.js
- c:\Users\rexma\Desktop\Les Chevalier du commit\Les-Chevaliers-du-Commit\script.js
- c:\Users\rexma\Desktop\Les Chevalier du commit\Les-Chevaliers-du-Commit\index.html

## c:\Users\rexma\Desktop\Les Chevalier du commit\Les-Chevaliers-du-Commit\labyrinthe.js
```
// labyrinthe.js - Version corrigée et fonctionnelle en français avec vue première personne

class MazeGame3D {
  constructor(container) {
    this.container = container;
    this.scene = null;
    this.camera = null;
    this.renderer = null;
    
    // Progression du jeu
    this.currentLevel = 1;
    this.maxLevel = 5;
    this.playerCoins = 0;
    this.levelProgress = {
      1: { coins: 0, required: 5, size: 15, unlocked: true, completed: false },
      2: { coins: 0, required: 8, size: 19, unlocked: false, completed: false },
      3: { coins: 0, required: 12, size: 23, unlocked: false, completed: false },
      4: { coins: 0, required: 15, size: 27, unlocked: false, completed: false },
      5: { coins: 0, required: 20, size: 31, unlocked: false, completed: false }
    };
    
    // Éléments du jeu
    this.maze = [];
    this.player = null;
    this.coins = [];
    this.solutionPath = [];
    this.walls = [];
    
    // Configuration de la caméra
    this.cameraMode = 'firstPerson'; // Mode première personne par défaut
    this.cameraOffset = new THREE.Vector3(0, 8, 10);
    this.lastDirection = new THREE.Vector3(0, 0, -1); // Direction initiale vers le nord
    
    // Contrôles
    this.keys = {};
    this.gameState = 'playing';
    this.moveSpeed = 0.15;
    
    // Chronomètre
    this.startTime = null;
    this.completionTimes = [];
    
    this.init();
  }

  async init() {
    console.log('Initialisation du labyrinthe 3D...');
    await this.loadThreeJS();
    this.setupScene();
    this.setupControls();
    this.loadProgress();
    this.generateLevel(this.currentLevel);
  }

  async loadThreeJS() {
    if (typeof THREE === 'undefined') {
      return new Promise((resolve, reject) => {
        const script = document.createElement('script');
        script.src = 'https://unpkg.com/three@0.157.0/build/three.min.js';
        script.onload = resolve;
        script.onerror = reject;
        document.head.appendChild(script);
      });
    }
    return Promise.resolve();
  }


  setupScene() {
    // Scène avec couleurs corrigées
    this.scene = new THREE.Scene();
  const loader = new THREE.TextureLoader();
loader.load('background.jpg', (texture) => {
    this.scene.background = texture;
});
    this.scene.fog = new THREE.Fog(0x2c1810, 20, 60);

    // Caméra
    this.camera = new THREE.PerspectiveCamera(
      75, 
      this.container.clientWidth / this.container.clientHeight, 
      0.1, 
      1000
    );
    this.camera.position.set(5, 10, 15);

    // Renderer
    this.renderer = new THREE.WebGLRenderer({ 
      antialias: true,
      alpha: false
    });
    this.renderer.setSize(this.container.clientWidth, this.container.clientHeight);
    this.renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    this.renderer.shadowMap.enabled = true;
    this.renderer.shadowMap.type = THREE.PCFSoftShadowMap;
    
    // Nettoyer et ajouter le canvas
    this.container.innerHTML = '';
    this.container.appendChild(this.renderer.domElement);

    // Éclairage
    const ambientLight = new THREE.AmbientLight(0xFFFFFF, 1.0); // Lumière ambiante dorée
    this.scene.add(ambientLight);

    const directionalLight = new THREE.DirectionalLight(0xFFFFFF, 1.0);
    directionalLight.position.set(20, 30, 10);
    directionalLight.castShadow = true;
    directionalLight.shadow.mapSize.width = 1024;
    directionalLight.shadow.mapSize.height = 1024;
    this.scene.add(directionalLight);

    // Gestionnaire de redimensionnement
    window.addEventListener('resize', () => this.onResize());
    
    // Démarrer l'animation
    this.animate();
    
    console.log('Scène 3D configurée correctement');
  }

  generateLevel(levelNumber) {
    console.log(`Génération du niveau ${levelNumber}...`);
    
    this.currentLevel = levelNumber;
    const levelConfig = this.levelProgress[levelNumber];
    
    if (!levelConfig.unlocked) {
      console.log(`Niveau ${levelNumber} verrouillé`);
      return;
    }

    // Nettoyer le niveau précédent
    this.clearLevel();
    
    // Générer le labyrinthe
    this.generateMaze(levelConfig.size);
    
    // Créer la géométrie 3D
    this.createWalls();
    this.createFloor();
    this.createPlayer();
    this.distributeCoins(levelConfig.required);
    this.findSolution();
    
    // Configurer la caméra sur le joueur
    this.updateCamera();
    
    // Démarrer le chronomètre
    this.startTime = Date.now();
    this.gameState = 'playing';
    
    // Mettre à jour l'interface utilisateur
    this.updateUI();
    
    console.log(`Niveau ${levelNumber} généré : ${levelConfig.size}x${levelConfig.size}`);
  }

  generateMaze(size) {
    this.mazeSize = size;
    this.maze = [];

    // Initialiser avec des murs
    for (let i = 0; i < size; i++) {
      this.maze[i] = [];
      for (let j = 0; j < size; j++) {
        this.maze[i][j] = 1;
      }
    }

    // Algorithme de retour récursif (Recursive Backtracking)
    this.generateMazeRecursive(1, 1);

    // Entrée et sortie
    this.maze[1][1] = 0;
    this.maze[size - 2][size - 2] = 0;
  }

  generateMazeRecursive(x, y) {
    const directions = [[2, 0], [0, 2], [-2, 0], [0, -2]];
    directions.sort(() => Math.random() - 0.5);

    this.maze[x][y] = 0;

    for (let [dx, dy] of directions) {
      const nx = x + dx;
      const ny = y + dy;

      if (nx >= 1 && nx < this.mazeSize - 1 && 
          ny >= 1 && ny < this.mazeSize - 1 && 
          this.maze[nx][ny] === 1) {
        
        this.maze[x + dx / 2][y + dy / 2] = 0;
        this.generateMazeRecursive(nx, ny);
      }
    }
  }

  createWalls() {
    const wallGeometry = new THREE.BoxGeometry(2, 3, 2);
    const wallMaterial = new THREE.MeshPhongMaterial({ 
      color:0xFFFFFF,
      metalness: 1,
      reflectivity: 1,
      roughness: 1
    });

    for (let i = 0; i < this.mazeSize; i++) {
      for (let j = 0; j < this.mazeSize; j++) {
        if (this.maze[i][j] === 1) {
          const wall = new THREE.Mesh(wallGeometry, wallMaterial);
          wall.position.set(i * 2, 1.5, j * 2);
          wall.castShadow = true;
          wall.receiveShadow = true;
          this.scene.add(wall);
        }
      }
    }
  }

  createFloor() {
    const floorGeometry = new THREE.PlaneGeometry(this.mazeSize * 2, this.mazeSize * 2);
    const floorMaterial = new THREE.MeshLambertMaterial({ 
      color: 0x504831
    });
    
    const floor = new THREE.Mesh(floorGeometry, floorMaterial);
    floor.rotation.x = -Math.PI / 2;
    floor.position.set((this.mazeSize - 1), 0, (this.mazeSize - 1));
    floor.receiveShadow = true;
    this.scene.add(floor);
  }

  createPlayer() {
    const playerGeometry = new THREE.CapsuleGeometry(0.4, 1.2);
    const playerMaterial = new THREE.MeshLambertMaterial({ 
      color: 0xFFD700,
      emissive: 0x666600
    });
    
    this.player = new THREE.Mesh(playerGeometry, playerMaterial);
    this.player.position.set(2, 1, 2);
    this.player.castShadow = true;
    this.scene.add(this.player);
    
    console.log('Joueur créé à la position :', this.player.position);
  }

  distributeCoins(coinCount) {
    this.coins = [];
    
    const freeCells = [];
    for (let i = 1; i < this.mazeSize - 1; i++) {
      for (let j = 1; j < this.mazeSize - 1; j++) {
        if (this.maze[i][j] === 0 && !(i === 1 && j === 1) && !(i === this.mazeSize - 2 && j === this.mazeSize - 2)) {
          freeCells.push({ x: i, y: j });
        }
      }
    }

    const minDistance = Math.max(3, Math.floor(this.mazeSize / 8));
    const placedCoins = [];
    
    for (let attempts = 0; attempts < coinCount * 10 && placedCoins.length < coinCount; attempts++) {
      const randomCell = freeCells[Math.floor(Math.random() * freeCells.length)];
      
      let validPosition = true;
      for (let placed of placedCoins) {
        const distance = Math.abs(placed.x - randomCell.x) + Math.abs(placed.y - randomCell.y);
        if (distance < minDistance) {
          validPosition = false;
          break;
        }
      }
      
      if (validPosition) {
        placedCoins.push(randomCell);
      }
    }

    placedCoins.forEach((pos, index) => {
      const coinGeometry = new THREE.CylinderGeometry(0.3, 0.3, 0.1, 16);
      const coinMaterial = new THREE.MeshLambertMaterial({ 
        color: 0xFFD700,
        emissive: 0x332200
      });
      
      const coin = new THREE.Mesh(coinGeometry, coinMaterial);
      coin.position.set(pos.x * 2, 0.5, pos.y * 2);
      coin.userData = { 
        id: index, 
        collected: false,
        originalY: 0.5
      };
      
      this.coins.push(coin);
      this.scene.add(coin);
    });

    console.log(`${placedCoins.length} pièces placées`);
  }

  findSolution() {
    const start = { x: 1, y: 1 };
    const end = { x: this.mazeSize - 2, y: this.mazeSize - 2 };
    this.solutionPath = this.findPathAStar(start, end);
    console.log(`Solution trouvée : ${this.solutionPath.length} étapes`);
  }

  findPathAStar(start, end) {
    const openSet = [start];
    const closedSet = [];
    const cameFrom = {};
    const gScore = {};
    const fScore = {};

    gScore[`${start.x},${start.y}`] = 0;
    fScore[`${start.x},${start.y}`] = this.heuristic(start, end);

    while (openSet.length > 0) {
      let current = openSet[0];
      let currentIndex = 0;

      for (let i = 1; i < openSet.length; i++) {
        if (fScore[`${openSet[i].x},${openSet[i].y}`] < fScore[`${current.x},${current.y}`]) {
          current = openSet[i];
          currentIndex = i;
        }
      }

      if (current.x === end.x && current.y === end.y) {
        const path = [];
        let temp = current;
        while (temp) {
          path.push(temp);
          temp = cameFrom[`${temp.x},${temp.y}`];
        }
        return path.reverse();
      }

      openSet.splice(currentIndex, 1);
      closedSet.push(current);

      const neighbors = this.getNeighbors(current);
      
      for (let neighbor of neighbors) {
        if (closedSet.some(node => node.x === neighbor.x && node.y === neighbor.y)) {
          continue;
        }

        const tentativeGScore = gScore[`${current.x},${current.y}`] + 1;

        if (!openSet.some(node => node.x === neighbor.x && node.y === neighbor.y)) {
          openSet.push(neighbor);
        } else if (tentativeGScore >= (gScore[`${neighbor.x},${neighbor.y}`] || Infinity)) {
          continue;
        }

        cameFrom[`${neighbor.x},${neighbor.y}`] = current;
        gScore[`${neighbor.x},${neighbor.y}`] = tentativeGScore;
        fScore[`${neighbor.x},${neighbor.y}`] = tentativeGScore + this.heuristic(neighbor, end);
      }
    }

    return [];
  }

  heuristic(a, b) {
    return Math.abs(a.x - b.x) + Math.abs(a.y - b.y);
  }

  getNeighbors(node) {
    const neighbors = [];
    const directions = [[1, 0], [0, 1], [-1, 0], [0, -1]];

    for (let [dx, dy] of directions) {
      const x = node.x + dx;
      const y = node.y + dy;

      if (x >= 0 && x < this.mazeSize && y >= 0 && y < this.mazeSize && this.maze[x][y] === 0) {
        neighbors.push({ x, y });
      }
    }

    return neighbors;
  }

  showSolution(show = true) {
    // Nettoyer la solution précédente
    this.scene.children = this.scene.children.filter(child => 
      !(child.userData && child.userData.isSolutionPath)
    );

    if (!show || this.solutionPath.length === 0) return;

    const pathMaterial = new THREE.MeshBasicMaterial({ 
      color: 0x00FF88,
      transparent: true,
      opacity: 0.6
    });

    this.solutionPath.forEach(({ x, y }) => {
      const pathGeometry = new THREE.RingGeometry(0.3, 0.8);
      const pathMesh = new THREE.Mesh(pathGeometry, pathMaterial);
      pathMesh.position.set(x * 2, 0.05, y * 2);
      pathMesh.rotation.x = -Math.PI / 2;
      pathMesh.userData = { isSolutionPath: true };
      this.scene.add(pathMesh);
    });

    console.log('Solution montrée');
  }

  setupControls() {
    // Événements du clavier
    document.addEventListener('keydown', (e) => {
      this.keys[e.code] = true;
      console.log('Touche appuyée :', e.code);
    });

    document.addEventListener('keyup', (e) => {
      this.keys[e.code] = false;
    });

    console.log('Contrôles configurés');
  }

  update() {
    if (this.gameState !== 'playing' || !this.player) return;

    // Mouvement du joueur
    const originalPos = this.player.position.clone();
    let moved = false;
    let moveDirection = new THREE.Vector3(0, 0, 0);

    if (this.keys['KeyW'] || this.keys['ArrowUp']) {
      this.player.position.z -= this.moveSpeed;
      moveDirection.z = -1;
      moved = true;
    }
    if (this.keys['KeyS'] || this.keys['ArrowDown']) {
      this.player.position.z += this.moveSpeed;
      moveDirection.z = 1;
      moved = true;
    }
    if (this.keys['KeyA'] || this.keys['ArrowLeft']) {
      this.player.position.x -= this.moveSpeed;
      moveDirection.x = -1;
      moved = true;
    }
    if (this.keys['KeyD'] || this.keys['ArrowRight']) {
      this.player.position.x += this.moveSpeed;
      moveDirection.x = 1;
      moved = true;
    }

    // Mettre à jour la direction de vue
    if (moved && (moveDirection.x !== 0 || moveDirection.z !== 0)) {
      this.lastDirection.copy(moveDirection.normalize());
    }

    // Vérifier les collisions
    if (moved) {
      if (this.checkCollision()) {
        this.player.position.copy(originalPos);
      }
    }

    // Mettre à jour la caméra toujours (important pour la première personne)
    this.updateCamera();

    // Vérifier les collisions avec les pièces
    this.checkCoinCollisions();

    // Animer les pièces
    this.animateCoins();

    // Vérifier la victoire
    this.checkLevelCompletion();
  }

  checkCollision() {
    const gridX = Math.round(this.player.position.x / 2);
    const gridZ = Math.round(this.player.position.z / 2);
    
    if (gridX < 0 || gridX >= this.mazeSize || 
        gridZ < 0 || gridZ >= this.mazeSize || 
        this.maze[gridX][gridZ] === 1) {
      return true;
    }
    
    return false;
  }

  checkCoinCollisions() {
    this.coins.forEach(coin => {
      if (!coin.userData.collected) {
        const distance = this.player.position.distanceTo(coin.position);
        if (distance < 1.2) {
          this.collectCoin(coin);
        }
      }
    });
  }

  collectCoin(coin) {
    coin.userData.collected = true;
    this.playerCoins++;
    this.levelProgress[this.currentLevel].coins++;
    
    // Effet de collecte
    this.scene.remove(coin);
    
    // Mettre à jour l'interface utilisateur
    this.updateUI();
    
    console.log(`Pièce collectée ! Total : ${this.playerCoins}`);
  }

  animateCoins() {
    this.coins.forEach(coin => {
      if (!coin.userData.collected) {
        coin.rotation.y += 0.03;
        coin.position.y = coin.userData.originalY + Math.sin(Date.now() * 0.003 + coin.userData.id) * 0.15;
      }
    });
  }

  checkLevelCompletion() {
    const levelConfig = this.levelProgress[this.currentLevel];
    const hasRequiredCoins = levelConfig.coins >= levelConfig.required;
    const gridX = Math.round(this.player.position.x / 2);
    const gridZ = Math.round(this.player.position.z / 2);
    const isAtExit = gridX === this.mazeSize - 2 && gridZ === this.mazeSize - 2;
    
    if (hasRequiredCoins && isAtExit && !levelConfig.completed) {
      this.completeLevel();
    }
  }

  completeLevel() {
    const completionTime = Date.now() - this.startTime;
    this.completionTimes.push(completionTime);
    
    const levelConfig = this.levelProgress[this.currentLevel];
    levelConfig.completed = true;
    
    if (this.currentLevel < this.maxLevel) {
      this.levelProgress[this.currentLevel + 1].unlocked = true;
    }
    
    this.gameState = 'completed';
    this.saveProgress();
    
    this.showLevelCompleteMessage(completionTime);
    
    console.log(`Niveau ${this.currentLevel} complété en ${(completionTime / 1000).toFixed(1)}s`);
  }

  showLevelCompleteMessage(time) {
    const timeStr = (time / 1000).toFixed(1);
    const isLastLevel = this.currentLevel === this.maxLevel;
    
    if (isLastLevel) {
      window.dispatchEvent(new CustomEvent('treasureFound', {
        detail: {
          level: this.currentLevel,
          time: timeStr,
          totalCoins: this.playerCoins
        }
      }));
    } else {
      window.dispatchEvent(new CustomEvent('levelComplete', {
        detail: {
          level: this.currentLevel,
          time: timeStr,
          nextLevel: this.currentLevel + 1
        }
      }));
    }
  }

  nextLevel() {
    if (this.currentLevel < this.maxLevel && this.levelProgress[this.currentLevel + 1].unlocked) {
      this.generateLevel(this.currentLevel + 1);
    }
  }

  updateCamera() {
    if (!this.player) return;

    const targetPos = this.player.position.clone();
    
    if (this.cameraMode === 'firstPerson') {
      // Cacher le personnage en première personne
      this.player.visible = false;
      
      // Vue en première personne - caméra au niveau des yeux
      const eyeHeight = 1.5; // Hauteur des yeux du personnage
      this.camera.position.set(
        targetPos.x,
        targetPos.y + eyeHeight,
        targetPos.z
      );
      
      // Regarder vers l'avant en fonction du dernier mouvement
      const lookAtPoint = new THREE.Vector3(
        targetPos.x + this.lastDirection.x * 5,
        targetPos.y + eyeHeight,
        targetPos.z + this.lastDirection.z * 5
      );
      this.camera.lookAt(lookAtPoint);
      
    } else if (this.cameraMode === 'thirdPerson') {
      // Montrer le personnage en troisième personne
      this.player.visible = true;
      
      this.camera.position.lerp(
        new THREE.Vector3(
          targetPos.x + this.cameraOffset.x,
          targetPos.y + this.cameraOffset.y,
          targetPos.z + this.cameraOffset.z
        ),
        0.1
      );
      this.camera.lookAt(targetPos);
    } else if (this.cameraMode === 'topDown') {
      // Montrer le personnage en vue aérienne
      this.player.visible = true;
      
      this.camera.position.lerp(
        new THREE.Vector3(targetPos.x, targetPos.y - 90, targetPos.z),
        0.1
      );
      this.camera.lookAt(targetPos);
    }
  }

  setCameraMode(mode) {
    this.cameraMode = mode;
    console.log('Mode de caméra :', mode);
  }

  clearLevel() {
    const objectsToRemove = [];
    this.scene.traverse(child => {
      if (child.isMesh && child !== this.player) {
        objectsToRemove.push(child);
      }
    });
    
    objectsToRemove.forEach(obj => {
      this.scene.remove(obj);
    });
    
    this.coins = [];
    this.solutionPath = [];
  }

  saveProgress() {
    localStorage.setItem('kaamelottMazeProgress', JSON.stringify({
      levelProgress: this.levelProgress,
      currentLevel: this.currentLevel,
      playerCoins: this.playerCoins,
      completionTimes: this.completionTimes
    }));
  }

  loadProgress() {
    const saved = localStorage.getItem('kaamelottMazeProgress');
    if (saved) {
      const data = JSON.parse(saved);
      this.levelProgress = data.levelProgress || this.levelProgress;
      this.currentLevel = data.currentLevel || 1;
      this.playerCoins = data.playerCoins || 0;
      this.completionTimes = data.completionTimes || [];
    }
  }

  updateUI() {
    const event = new CustomEvent('mazeUIUpdate', {
      detail: {
        currentLevel: this.currentLevel,
        maxLevel: this.maxLevel,
        coins: this.levelProgress[this.currentLevel].coins,
        requiredCoins: this.levelProgress[this.currentLevel].required,
        totalCoins: this.playerCoins,
        levelProgress: this.levelProgress
      }
    });
    window.dispatchEvent(event);
  }

  animate() {
    requestAnimationFrame(() => this.animate());
    
    this.update();
    
    if (this.renderer && this.scene && this.camera) {
      this.renderer.render(this.scene, this.camera);
    }
  }

  onResize() {
    if (!this.camera || !this.renderer) return;
    
    this.camera.aspect = this.container.clientWidth / this.container.clientHeight;
    this.camera.updateProjectionMatrix();
    this.renderer.setSize(this.container.clientWidth, this.container.clientHeight);
  }

  reset() {
    this.generateLevel(this.currentLevel);
  }
}

// Exporter pour utilisation globale
window.MazeGame3D = MazeGame3D;
```

## c:\Users\rexma\Desktop\Les Chevalier du commit\Les-Chevaliers-du-Commit\script.js
```
// script.js - Version corrigée et simplifiée en français

// Variables globales pour Leaflet
let map;
let kaamelottMarker, labyrinthMarker;
let waypoints = [];
let waypointMarkers = [];
let routingControl;
let customRoute;

// Variable pour le labyrinthe 3D
let mazeGame3D;

// Coordonnées
const kaamelottCoords = [43.3124, -0.3668];
const labyrinthCoords = [43.2933, -0.3708];

const predefinedWaypoints = [
  [43.305, -0.365, "Place Verdun", "🏛️"],
  [43.298, -0.372, "Université de Pau", "🎓"],
  [43.31, -0.36, "Parc Lawrence", "🌳"],
  [43.3, -0.368, "Centre-ville de Pau", "🏪"],
  [43.315, -0.372, "Boulevard des Pyrénées", "🏔️"],
  [43.308, -0.359, "Stade du Hameau", "⚽"],
  [43.295, -0.375, "Gare SNCF de Pau", "🚂"],
];

// ============= INITIALISATION =============

window.onload = function () {
  console.log('Initialisation de l\'application...');
  initMap();
  setupMazeEventListeners();
};

// ============= FONCTIONS DE CARTE =============

function initMap() {
  map = L.map("map").setView([43.3028, -0.3678], 14);

  const osmLayer = L.tileLayer(
    "https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png",
    {
      attribution: "© Contributeurs OpenStreetMap",
      maxZoom: 19,
    }
  );

  const cartoLayer = L.tileLayer(
    "https://{s}.basemaps.cartocdn.com/rastertiles/voyager/{z}/{x}/{y}{r}.png",
    {
      attribution: "© CARTO © Contributeurs OpenStreetMap",
      maxZoom: 19,
    }
  );

  osmLayer.addTo(map);

  const baseMaps = {
    OpenStreetMap: osmLayer,
    "CartoDB Voyager": cartoLayer,
  };
  L.control.layers(baseMaps).addTo(map);

  const kaamelottIcon = L.divIcon({
    html: '<div style="background: linear-gradient(45deg, #32CD32, #228B22); border: 3px solid #FFD700; border-radius: 50%; width: 40px; height: 40px; display: flex; align-items: center; justify-content: center; font-size: 20px; box-shadow: 0 0 15px rgba(50, 205, 50, 0.7);">🏰</div>',
    iconSize: [40, 40],
    iconAnchor: [20, 20],
    popupAnchor: [0, -20],
    className: "custom-marker",
  });

  const labyrinthIcon = L.divIcon({
    html: '<div style="background: linear-gradient(45deg, #FF6B6B, #FF4444); border: 3px solid #FFD700; border-radius: 50%; width: 40px; height: 40px; display: flex; align-items: center; justify-content: center; font-size: 20px; box-shadow: 0 0 15px rgba(255, 107, 107, 0.7);">🌀</div>',
    iconSize: [40, 40],
    iconAnchor: [20, 20],
    popupAnchor: [0, -20],
    className: "custom-marker",
  });

  kaamelottMarker = L.marker(kaamelottCoords, { icon: kaamelottIcon })
    .addTo(map)
    .bindPopup(`
      <div style="text-align: center;">
        <h3>🏰 Kaamelott</h3>
        <p><strong>Pôle Lahérrère, Pau</strong></p>
        <p>Point de départ de la quête</p>
      </div>
    `);

  labyrinthMarker = L.marker(labyrinthCoords, { icon: labyrinthIcon })
    .addTo(map)
    .bindPopup(`
      <div style="text-align: center;">
        <h3>🌀 Entrée du Labyrinthe</h3>
        <p><strong>Château de Pau</strong></p>
        <p>Destination finale</p>
      </div>
    `);

  L.circle(kaamelottCoords, {
    color: "#32CD32",
    fillColor: "#32CD32",
    fillOpacity: 0.1,
    radius: 200,
  }).addTo(map);

  L.circle(labyrinthCoords, {
    color: "#FF6B6B",
    fillColor: "#FF6B6B",
    fillOpacity: 0.1,
    radius: 200,
  }).addTo(map);

  predefinedWaypoints.slice(0, 3).forEach((wp) => {
    addWaypointAt(wp[0], wp[1], wp[2], wp[3]);
  });

  console.log('Carte initialisée correctement');
}

function showPhase(phase) {
  console.log('Changement vers la phase:', phase);
  
  document.querySelectorAll(".phase-btn").forEach((btn) => btn.classList.remove("active"));
  document.querySelectorAll('[id$="-container"]').forEach((container) => container.classList.remove("active"));

  event.target.classList.add("active");
  document.getElementById(phase + "-container").classList.add("active");

  if (phase === "map" && map) {
    setTimeout(() => map.invalidateSize(), 100);
  } else if (phase === "maze") {
    if (!mazeGame3D) {
      console.log('Initialisation du labyrinthe 3D pour la première fois...');
      initMaze3D();
    } else {
      console.log('Le labyrinthe 3D existe déjà');
    }
  }
}

function addWaypoint() {
  if (waypoints.length < predefinedWaypoints.length) {
    const wp = predefinedWaypoints[waypoints.length];
    addWaypointAt(wp[0], wp[1], wp[2], wp[3]);
    updateStatus("map", `Point de passage "${wp[2]}" ajouté !`, "success");
  } else {
    updateStatus("map", "Tous les points de passage ont été ajoutés !", "info");
  }
}

function addWaypointAt(lat, lng, name, emoji) {
  const waypointIcon = L.divIcon({
    html: `<div style="background: linear-gradient(45deg, #FFD700, #FFA500); border: 3px solid #DAA520; border-radius: 50%; width: 35px; height: 35px; display: flex; align-items: center; justify-content: center; font-size: 16px; box-shadow: 0 0 12px rgba(255, 215, 0, 0.7);">${emoji}</div>`,
    iconSize: [35, 35],
    iconAnchor: [17, 17],
    popupAnchor: [0, -17],
    className: "custom-marker",
  });

  const marker = L.marker([lat, lng], { icon: waypointIcon })
    .addTo(map)
    .bindPopup(`
      <div style="text-align: center;">
        <h4>${emoji} ${name}</h4>
        <p>Point de passage #${waypoints.length + 1}</p>
      </div>
    `);

  waypoints.push({ marker, coords: [lat, lng], name, emoji });
  waypointMarkers.push(marker);

  L.circle([lat, lng], {
    color: "#FFD700",
    fillColor: "#FFD700",
    fillOpacity: 0.1,
    radius: 100,
  }).addTo(map);
}

function findShortestPath() {
  if (waypoints.length === 0) {
    updateStatus("map", "Ajoutez au moins un point de passage !", "error");
    return;
  }

  updateStatus("map", "Calcul du chemin optimal...", "loading");
  clearPath();

  setTimeout(() => {
    let routeWaypoints = [L.latLng(kaamelottCoords[0], kaamelottCoords[1])];
    let unvisitedWaypoints = [...waypoints];
    let currentPos = kaamelottCoords;

    while (unvisitedWaypoints.length > 0) {
      let nearest = unvisitedWaypoints[0];
      let nearestIndex = 0;
      let minDistance = calculateDistance(currentPos, nearest.coords);

      for (let i = 1; i < unvisitedWaypoints.length; i++) {
        let distance = calculateDistance(currentPos, unvisitedWaypoints[i].coords);
        if (distance < minDistance) {
          minDistance = distance;
          nearest = unvisitedWaypoints[i];
          nearestIndex = i;
        }
      }

      routeWaypoints.push(L.latLng(nearest.coords[0], nearest.coords[1]));
      currentPos = nearest.coords;
      unvisitedWaypoints.splice(nearestIndex, 1);
    }

    routeWaypoints.push(L.latLng(labyrinthCoords[0], labyrinthCoords[1]));

    routingControl = L.Routing.control({
      waypoints: routeWaypoints,
      routeWhileDragging: false,
      addWaypoints: false,
      createMarker: () => null,
      lineOptions: {
        styles: [{ color: "#4169E1", weight: 6, opacity: 0.8, dashArray: "10, 5" }]
      },
      show: true,
      collapsible: true,
      router: L.Routing.osrmv1({
        serviceUrl: "https://router.project-osrm.org/route/v1",
        profile: "walking"
      })
    }).addTo(map);

    routingControl.on("routesfound", (e) => {
      const routes = e.routes;
      const summary = routes[0].summary;
      const distance = (summary.totalDistance / 1000).toFixed(2);
      const time = Math.round(summary.totalTime / 60);
      updateStatus("map", `🎯 Chemin calculé ! Distance: ${distance} km | Temps: ${time} min`, "success");
    });

    routingControl.on("routingerror", () => {
      updateStatus("map", "Erreur - Utilisation du chemin direct", "error");
      createManualRoute(routeWaypoints);
    });
  }, 1000);
}

function createManualRoute(waypoints) {
  const pathCoords = waypoints.map((wp) => [wp.lat, wp.lng]);
  customRoute = L.polyline(pathCoords, {
    color: "#4169E1",
    weight: 6,
    opacity: 0.8,
    dashArray: "10, 5"
  }).addTo(map);

  let totalDistance = 0;
  for (let i = 0; i < pathCoords.length - 1; i++) {
    totalDistance += calculateDistance(pathCoords[i], pathCoords[i + 1]);
  }
  updateStatus("map", `Chemin calculé ! Distance: ${totalDistance.toFixed(2)} km`, "success");
}

function clearPath() {
  if (routingControl) {
    map.removeControl(routingControl);
    routingControl = null;
  }
  if (customRoute) {
    map.removeLayer(customRoute);
    customRoute = null;
  }
}

function calculateDistance(coord1, coord2) {
  const latlng1 = L.latLng(coord1[0], coord1[1]);
  const latlng2 = L.latLng(coord2[0], coord2[1]);
  return latlng1.distanceTo(latlng2) / 1000;
}

function centerOnKaamelott() {
  map.setView(kaamelottCoords, 15);
  kaamelottMarker.openPopup();
}

// ============= LABYRINTHE 3D =============

function initMaze3D() {
  console.log('Appel à initMaze3D...');
  updateStatus("maze", "Chargement du labyrinthe 3D...", "loading");
  
  const mazeContainer = document.getElementById("maze");
  
  if (!mazeContainer) {
    console.error('Le conteneur #maze n\'a pas été trouvé');
    return;
  }
  
  try {
    mazeGame3D = new MazeGame3D(mazeContainer);
    updateMazeControls();
    updateStatus("maze", "¡Labyrinthe 3D prêt ! Utilisez WASD pour vous déplacer", "success");
    console.log('Labyrinthe 3D initialisé correctement');
  } catch (error) {
    console.error('Erreur lors de l\'initialisation du labyrinthe:', error);
    updateStatus("maze", "Erreur lors du chargement du labyrinthe 3D", "error");
  }
}

function updateMazeControls() {
  const controlsContainer = document.querySelector('#maze-container .controls');
  if (!controlsContainer) return;
  
  controlsContainer.innerHTML = `
    <button class="control-btn" onclick="generateMaze()">🔄 Réinitialiser Niveau</button>
    <button class="control-btn" onclick="solveMaze()">🧭 Montrer Solution</button>
    <button class="control-btn" onclick="toggleCameraMode()">📷 Changer Vue</button>
    <button class="control-btn" onclick="nextLevel()" id="next-level-btn" style="display: none;">⏭️ Niveau Suivant</button>
    <button class="control-btn" onclick="resetProgress()">🗑️ Reset Progrès</button>
  `;

  updateMazeInfoPanel();
}

function updateMazeInfoPanel() {
  const infoPanelContainer = document.querySelector('#maze-container .info-panel');
  if (!infoPanelContainer) return;
  
  infoPanelContainer.innerHTML = `
    <div id="maze-status" class="status">¡Explorez le labyrinthe 3D ! Utilisez WASD ou les flèches pour vous déplacer</div>
    
    <div class="level-progress">
      <div class="progress-header">
        <span id="level-indicator">Niveau 1/5</span>
        <span id="coins-counter">💰 0/5</span>
      </div>
      <div class="progress-bar-container">
        <div class="progress-bar" id="progress-bar"></div>
      </div>
    </div>

    <div class="game-stats">
      <div class="stat-item">
        <span class="stat-label">Temps :</span>
        <span class="stat-value" id="timer">00:00</span>
      </div>
      <div class="stat-item">
        <span class="stat-label">Pièces totales :</span>
        <span class="stat-value" id="total-coins">0</span>
      </div>
    </div>

    <div class="controls-help">
      <h4>🎮 Contrôles</h4>
      <div class="control-item"><kbd>WASD</kbd> ou <kbd>↑↓←→</kbd> - Déplacer Arthur</div>
      <div class="control-item"><kbd>📷</kbd> - Changer vue (1ère personne / 3ème personne / Aérienne)</div>
    </div>

    <div class="legend">
      <div class="legend-item">
        <div class="legend-color" style="background: #FFD700;"></div>
        <span>Arthur / Pièces</span>
      </div>
      <div class="legend-item">
        <div class="legend-color" style="background: #00FF88;"></div>
        <span>Solution</span>
      </div>
      <div class="legend-item">
        <div class="legend-color" style="background: #8B4513;"></div>
        <span>Murs</span>
      </div>
    </div>
  `;
}

function generateMaze() {
  console.log('Appel à generateMaze...');
  if (mazeGame3D) {
    mazeGame3D.reset();
    updateStatus("maze", "¡Niveau réinitialisé !", "success");
  } else {
    initMaze3D();
  }
}

function solveMaze() {
  console.log('Appel à solveMaze...');
  if (mazeGame3D) {
    mazeGame3D.showSolution(true);
    updateStatus("maze", "Solution montrée en vert", "success");
    
    setTimeout(() => {
      mazeGame3D.showSolution(false);
      updateStatus("maze", "Solution cachée. Essayez maintenant !", "info");
    }, 5000);
  }
}

function toggleCameraMode() {
  console.log('Appel à toggleCameraMode...');
  if (mazeGame3D) {
    const currentMode = mazeGame3D.cameraMode;
    let newMode, modeText;
    
    // Cycle : première personne -> troisième personne -> vue aérienne -> première personne
    if (currentMode === 'firstPerson') {
      newMode = 'thirdPerson';
      modeText = '👤 Troisième Personne';
    } else if (currentMode === 'thirdPerson') {
      newMode = 'topDown';
      modeText = '🦅 Vue Aérienne';
    } else {
      newMode = 'firstPerson';
      modeText = '👁️ Première Personne';
    }
    
    mazeGame3D.setCameraMode(newMode);
    updateStatus("maze", `Vue changée vers ${modeText}`, "info");
  }
}

function nextLevel() {
  console.log('Appel à nextLevel...');
  if (mazeGame3D) {
    mazeGame3D.nextLevel();
    document.getElementById('next-level-btn').style.display = 'none';
  }
}

function resetProgress() {
  if (confirm('Êtes-vous sûr de réinitialiser tout le progrès ?')) {
    localStorage.removeItem('kaamelottMazeProgress');
    location.reload();
  }
}

// ============= ÉVÉNEMENTS =============

function setupMazeEventListeners() {
  console.log('Configuration des écouteurs d\'événements du labyrinthe...');
  
  window.addEventListener('mazeUIUpdate', (event) => {
    const data = event.detail;
    
    const levelIndicator = document.getElementById('level-indicator');
    const coinsCounter = document.getElementById('coins-counter');
    const totalCoins = document.getElementById('total-coins');
    const progressBar = document.getElementById('progress-bar');
    
    if (levelIndicator) levelIndicator.textContent = `Niveau ${data.currentLevel}/${data.maxLevel}`;
    if (coinsCounter) coinsCounter.textContent = `💰 ${data.coins}/${data.requiredCoins}`;
    if (totalCoins) totalCoins.textContent = data.totalCoins;
    if (progressBar) progressBar.style.width = `${(data.coins / data.requiredCoins) * 100}%`;
  });

  window.addEventListener('levelComplete', (event) => {
    const data = event.detail;
    updateStatus("maze", `🎉 Niveau ${data.level} complété en ${data.time}s !`, "success");
    
    const nextBtn = document.getElementById('next-level-btn');
    if (nextBtn) nextBtn.style.display = 'inline-block';
    
    setTimeout(() => nextLevel(), 3000);
  });

  window.addEventListener('treasureFound', (event) => {
    const data = event.detail;
    updateStatus("maze", `🏆 FÉLICITATIONS ! Vous avez complété tous les niveaux avec ${data.totalCoins} pièces !`, "success");
    showFinalVictoryMessage(data);
  });
}

function showFinalVictoryMessage(data) {
  const mazeStatus = document.getElementById('maze-status');
  if (!mazeStatus) return;
  
  mazeStatus.innerHTML = `
    <div class="final-victory">
      <h2>🏆 QUÊTE COMPLÈTE !</h2>
      <p>Arthur a trouvé le trésor de la Dame du Lac !</p>
      <div class="victory-stats">
        <div class="victory-stat"><strong>Temps :</strong> ${data.time}s</div>
        <div class="victory-stat"><strong>Pièces :</strong> ${data.totalCoins}</div>
        <div class="victory-stat"><strong>Niveaux :</strong> 5/5</div>
      </div>
      <button class="control-btn" onclick="resetProgress()">🔄 Rejouer</button>
    </div>
  `;
  mazeStatus.className = 'status victory';
}

let gameTimer;

function startGameTimer() {
  if (gameTimer) clearInterval(gameTimer);
  
  const startTime = Date.now();
  gameTimer = setInterval(() => {
    const elapsed = Date.now() - startTime;
    const seconds = Math.floor(elapsed / 1000);
    const minutes = Math.floor(seconds / 60);
    const displaySeconds = seconds % 60;
    
    const timerElement = document.getElementById('timer');
    if (timerElement) {
      timerElement.textContent = `${minutes.toString().padStart(2, '0')}:${displaySeconds.toString().padStart(2, '0')}`;
    }
  }, 1000);
}

function updateStatus(phase, message, type = "info") {
  const statusElement = document.getElementById(phase + "-status");
  if (statusElement) {
    statusElement.textContent = message;
    statusElement.className = "status " + type;
  }
  console.log(`Status [${phase}]:`, message);
}

window.addEventListener('mazeUIUpdate', () => {
  if (!gameTimer) startGameTimer();
});
```

## c:\Users\rexma\Desktop\Les Chevalier du commit\Les-Chevaliers-du-Commit\index.html
```
<!DOCTYPE html>
<html lang="fr">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Quête de Kaamelott - La Recherche du Trésor</title>
    <link rel="stylesheet" href="style.css">
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <link rel="stylesheet" href="https://unpkg.com/leaflet-routing-machine@3.2.12/dist/leaflet-routing-machine.css" />
</head>

<body>
    <div class="container">
        <h1>⚔️ Quête de Kaamelott ⚔️</h1>

        <div class="quest-info">
            <p><strong>Mission :</strong> Aider le roi Arthur à trouver l'entrée du labyrinthe, puis le guider vers le
                trésor mystérieux de la Dame du Lac à travers 5 niveaux progressifs!</p>
        </div>

        <div class="phase-selector">
            <button class="phase-btn active" onclick="showPhase('map')">🗺️ Carte du Royaume</button>
            <button class="phase-btn" onclick="showPhase('maze')">🏰 Labyrinthe 3D</button>
        </div>

        <div id="map-container" class="active">
            <div id="map"></div>
            <div class="controls">
                <button class="control-btn" onclick="findShortestPath()">🧭 Calculer Route Optimale</button>
                <button class="control-btn" onclick="clearPath()">🧹 Effacer le Chemin</button>
                <button class="control-btn" onclick="addWaypoint()">📍 Ajouter Point de Passage</button>
                <button class="control-btn" onclick="centerOnKaamelott()">🏰 Centrer sur Kaamelott</button>
            </div>
            <div class="info-panel">
                <div id="map-status" class="status">Calculez la route optimale pour trouver l'entrée du labyrinthe!</div>
                <div class="legend">
                    <div class="legend-item">
                        <div class="legend-color" style="background: #32CD32;"></div>
                        <span>Kaamelott</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background: #FF6B6B;"></div>
                        <span>Entrée du Labyrinthe</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background: #FFD700;"></div>
                        <span>Points de Passage</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background: #4169E1; border: 2px dashed white;"></div>
                        <span>Route Calculée</span>
                    </div>
                </div>
            </div>
        </div>

        <div id="maze-container">
            <div id="maze"></div>
            <div class="controls">
                <!-- Los controles se generan dinámicamente en script.js -->
            </div>
            <div class="info-panel">
                <!-- El panel de información se genera dinámicamente en script.js -->
            </div>
        </div>
    </div>

    <!-- Scripts en el orden correcto -->
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <script src="https://unpkg.com/leaflet-routing-machine@3.2.12/dist/leaflet-routing-machine.js"></script>
    <script src="https://unpkg.com/three@0.157.0/build/three.min.js"></script>
    <script src="labyrinthe.js"></script>
    <script src="script.js"></script>
</body>

</html>
```

