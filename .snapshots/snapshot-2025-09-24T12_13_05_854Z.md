Enter your prompt here

# Project Structure

└─ data.js
└─ style.css
└─ script.js
└─ labyrinthe.js
└─ index.html


# Project Files

- c:\Users\rexma\Desktop\Les Chevalier du commit\Les-Chevaliers-du-Commit\labyrinthe.js
- c:\Users\rexma\Desktop\Les Chevalier du commit\Les-Chevaliers-du-Commit\script.js
- c:\Users\rexma\Desktop\Les Chevalier du commit\Les-Chevaliers-du-Commit\style.css
- c:\Users\rexma\Desktop\Les Chevalier du commit\Les-Chevaliers-du-Commit\data.js
- c:\Users\rexma\Desktop\Les Chevalier du commit\Les-Chevaliers-du-Commit\index.html

## c:\Users\rexma\Desktop\Les Chevalier du commit\Les-Chevaliers-du-Commit\labyrinthe.js
```
// labyrinthe.js - Version corrigée et fonctionnelle en français avec vue première personne

class MazeGame3D {
  constructor(container) {
    this.container = container;
    this.scene = null;
    this.camera = null;
    this.renderer = null;
    
    // Progression du jeu
    this.currentLevel = 1;
    this.maxLevel = 5;
    this.playerCoins = 0;
    this.levelProgress = {
      1: { coins: 0, required: 5, size: 15, unlocked: true, completed: false },
      2: { coins: 0, required: 8, size: 19, unlocked: false, completed: false },
      3: { coins: 0, required: 12, size: 23, unlocked: false, completed: false },
      4: { coins: 0, required: 15, size: 27, unlocked: false, completed: false },
      5: { coins: 0, required: 20, size: 31, unlocked: false, completed: false }
    };
    
    // Éléments du jeu
    this.maze = [];
    this.player = null;
    this.coins = [];
    this.solutionPath = [];
    this.walls = [];
    
    // Configuration de la caméra
    this.cameraMode = 'firstPerson'; // Mode première personne par défaut
    this.cameraOffset = new THREE.Vector3(0, 8, 10);
    this.lastDirection = new THREE.Vector3(0, 0, -1); // Direction initiale vers le nord
    
    // Contrôles
    this.keys = {};
    this.gameState = 'playing';
    this.moveSpeed = 0.15;
    
    // Chronomètre
    this.startTime = null;
    this.completionTimes = [];
    
    this.init();
  }

  async init() {
    console.log('Initialisation du labyrinthe 3D...');
    await this.loadThreeJS();
    this.setupScene();
    this.setupControls();
    this.loadProgress();
    this.generateLevel(this.currentLevel);
  }

  async loadThreeJS() {
    if (typeof THREE === 'undefined') {
      return new Promise((resolve, reject) => {
        const script = document.createElement('script');
        script.src = 'https://unpkg.com/three@0.157.0/build/three.min.js';
        script.onload = resolve;
        script.onerror = reject;
        document.head.appendChild(script);
      });
    }
    return Promise.resolve();
  }

  setupScene() {
    // Scène avec couleurs corrigées
    this.scene = new THREE.Scene();
    this.scene.background = new THREE.Color(0xffd700); // Couleur marron foncé
    this.scene.fog = new THREE.Fog(0x2c1810, 20, 60);

    // Caméra
    this.camera = new THREE.PerspectiveCamera(
      75, 
      this.container.clientWidth / this.container.clientHeight, 
      0.1, 
      1000
    );
    this.camera.position.set(5, 10, 15);

    // Renderer
    this.renderer = new THREE.WebGLRenderer({ 
      antialias: true,
      alpha: false
    });
    this.renderer.setSize(this.container.clientWidth, this.container.clientHeight);
    this.renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    this.renderer.shadowMap.enabled = true;
    this.renderer.shadowMap.type = THREE.PCFSoftShadowMap;
    
    // Nettoyer et ajouter le canvas
    this.container.innerHTML = '';
    this.container.appendChild(this.renderer.domElement);

    // Éclairage
    const ambientLight = new THREE.AmbientLight(0xFFD700, 1.0); // Lumière ambiante dorée
    this.scene.add(ambientLight);

    const directionalLight = new THREE.DirectionalLight(0xFFFFFF, 1.0);
    directionalLight.position.set(20, 30, 10);
    directionalLight.castShadow = true;
    directionalLight.shadow.mapSize.width = 1024;
    directionalLight.shadow.mapSize.height = 1024;
    this.scene.add(directionalLight);

    // Gestionnaire de redimensionnement
    window.addEventListener('resize', () => this.onResize());
    
    // Démarrer l'animation
    this.animate();
    
    console.log('Scène 3D configurée correctement');
  }

  generateLevel(levelNumber) {
    console.log(`Génération du niveau ${levelNumber}...`);
    
    this.currentLevel = levelNumber;
    const levelConfig = this.levelProgress[levelNumber];
    
    if (!levelConfig.unlocked) {
      console.log(`Niveau ${levelNumber} verrouillé`);
      return;
    }

    // Nettoyer le niveau précédent
    this.clearLevel();
    
    // Générer le labyrinthe
    this.generateMaze(levelConfig.size);
    
    // Créer la géométrie 3D
    this.createWalls();
    this.createFloor();
    this.createPlayer();
    this.distributeCoins(levelConfig.required);
    this.findSolution();
    
    // Configurer la caméra sur le joueur
    this.updateCamera();
    
    // Démarrer le chronomètre
    this.startTime = Date.now();
    this.gameState = 'playing';
    
    // Mettre à jour l'interface utilisateur
    this.updateUI();
    
    console.log(`Niveau ${levelNumber} généré : ${levelConfig.size}x${levelConfig.size}`);
  }

  generateMaze(size) {
    this.mazeSize = size;
    this.maze = [];

    // Initialiser avec des murs
    for (let i = 0; i < size; i++) {
      this.maze[i] = [];
      for (let j = 0; j < size; j++) {
        this.maze[i][j] = 1;
      }
    }

    // Algorithme de retour récursif (Recursive Backtracking)
    this.generateMazeRecursive(1, 1);

    // Entrée et sortie
    this.maze[1][1] = 0;
    this.maze[size - 2][size - 2] = 0;
  }

  generateMazeRecursive(x, y) {
    const directions = [[2, 0], [0, 2], [-2, 0], [0, -2]];
    directions.sort(() => Math.random() - 0.5);

    this.maze[x][y] = 0;

    for (let [dx, dy] of directions) {
      const nx = x + dx;
      const ny = y + dy;

      if (nx >= 1 && nx < this.mazeSize - 1 && 
          ny >= 1 && ny < this.mazeSize - 1 && 
          this.maze[nx][ny] === 1) {
        
        this.maze[x + dx / 2][y + dy / 2] = 0;
        this.generateMazeRecursive(nx, ny);
      }
    }
  }

  createWalls() {
    const wallGeometry = new THREE.BoxGeometry(2, 3, 2);
    const wallMaterial = new THREE.MeshLambertMaterial({ 
      color: 0x8B4513
    });

    for (let i = 0; i < this.mazeSize; i++) {
      for (let j = 0; j < this.mazeSize; j++) {
        if (this.maze[i][j] === 1) {
          const wall = new THREE.Mesh(wallGeometry, wallMaterial);
          wall.position.set(i * 2, 1.5, j * 2);
          wall.castShadow = true;
          wall.receiveShadow = true;
          this.scene.add(wall);
        }
      }
    }
  }

  createFloor() {
    const floorGeometry = new THREE.PlaneGeometry(this.mazeSize * 2, this.mazeSize * 2);
    const floorMaterial = new THREE.MeshLambertMaterial({ 
      color: 0x2F4F2F
    });
    
    const floor = new THREE.Mesh(floorGeometry, floorMaterial);
    floor.rotation.x = -Math.PI / 2;
    floor.position.set((this.mazeSize - 1), 0, (this.mazeSize - 1));
    floor.receiveShadow = true;
    this.scene.add(floor);
  }

  createPlayer() {
    const playerGeometry = new THREE.CapsuleGeometry(0.4, 1.2);
    const playerMaterial = new THREE.MeshLambertMaterial({ 
      color: 0xFFD700,
      emissive: 0x666600
    });
    
    this.player = new THREE.Mesh(playerGeometry, playerMaterial);
    this.player.position.set(2, 1, 2);
    this.player.castShadow = true;
    this.scene.add(this.player);
    
    console.log('Joueur créé à la position :', this.player.position);
  }

  distributeCoins(coinCount) {
    this.coins = [];
    
    const freeCells = [];
    for (let i = 1; i < this.mazeSize - 1; i++) {
      for (let j = 1; j < this.mazeSize - 1; j++) {
        if (this.maze[i][j] === 0 && !(i === 1 && j === 1) && !(i === this.mazeSize - 2 && j === this.mazeSize - 2)) {
          freeCells.push({ x: i, y: j });
        }
      }
    }

    const minDistance = Math.max(3, Math.floor(this.mazeSize / 8));
    const placedCoins = [];
    
    for (let attempts = 0; attempts < coinCount * 10 && placedCoins.length < coinCount; attempts++) {
      const randomCell = freeCells[Math.floor(Math.random() * freeCells.length)];
      
      let validPosition = true;
      for (let placed of placedCoins) {
        const distance = Math.abs(placed.x - randomCell.x) + Math.abs(placed.y - randomCell.y);
        if (distance < minDistance) {
          validPosition = false;
          break;
        }
      }
      
      if (validPosition) {
        placedCoins.push(randomCell);
      }
    }

    placedCoins.forEach((pos, index) => {
      const coinGeometry = new THREE.CylinderGeometry(0.3, 0.3, 0.1, 16);
      const coinMaterial = new THREE.MeshLambertMaterial({ 
        color: 0xFFD700,
        emissive: 0x332200
      });
      
      const coin = new THREE.Mesh(coinGeometry, coinMaterial);
      coin.position.set(pos.x * 2, 0.5, pos.y * 2);
      coin.userData = { 
        id: index, 
        collected: false,
        originalY: 0.5
      };
      
      this.coins.push(coin);
      this.scene.add(coin);
    });

    console.log(`${placedCoins.length} pièces placées`);
  }

  findSolution() {
    const start = { x: 1, y: 1 };
    const end = { x: this.mazeSize - 2, y: this.mazeSize - 2 };
    this.solutionPath = this.findPathAStar(start, end);
    console.log(`Solution trouvée : ${this.solutionPath.length} étapes`);
  }

  findPathAStar(start, end) {
    const openSet = [start];
    const closedSet = [];
    const cameFrom = {};
    const gScore = {};
    const fScore = {};

    gScore[`${start.x},${start.y}`] = 0;
    fScore[`${start.x},${start.y}`] = this.heuristic(start, end);

    while (openSet.length > 0) {
      let current = openSet[0];
      let currentIndex = 0;

      for (let i = 1; i < openSet.length; i++) {
        if (fScore[`${openSet[i].x},${openSet[i].y}`] < fScore[`${current.x},${current.y}`]) {
          current = openSet[i];
          currentIndex = i;
        }
      }

      if (current.x === end.x && current.y === end.y) {
        const path = [];
        let temp = current;
        while (temp) {
          path.push(temp);
          temp = cameFrom[`${temp.x},${temp.y}`];
        }
        return path.reverse();
      }

      openSet.splice(currentIndex, 1);
      closedSet.push(current);

      const neighbors = this.getNeighbors(current);
      
      for (let neighbor of neighbors) {
        if (closedSet.some(node => node.x === neighbor.x && node.y === neighbor.y)) {
          continue;
        }

        const tentativeGScore = gScore[`${current.x},${current.y}`] + 1;

        if (!openSet.some(node => node.x === neighbor.x && node.y === neighbor.y)) {
          openSet.push(neighbor);
        } else if (tentativeGScore >= (gScore[`${neighbor.x},${neighbor.y}`] || Infinity)) {
          continue;
        }

        cameFrom[`${neighbor.x},${neighbor.y}`] = current;
        gScore[`${neighbor.x},${neighbor.y}`] = tentativeGScore;
        fScore[`${neighbor.x},${neighbor.y}`] = tentativeGScore + this.heuristic(neighbor, end);
      }
    }

    return [];
  }

  heuristic(a, b) {
    return Math.abs(a.x - b.x) + Math.abs(a.y - b.y);
  }

  getNeighbors(node) {
    const neighbors = [];
    const directions = [[1, 0], [0, 1], [-1, 0], [0, -1]];

    for (let [dx, dy] of directions) {
      const x = node.x + dx;
      const y = node.y + dy;

      if (x >= 0 && x < this.mazeSize && y >= 0 && y < this.mazeSize && this.maze[x][y] === 0) {
        neighbors.push({ x, y });
      }
    }

    return neighbors;
  }

  showSolution(show = true) {
    // Nettoyer la solution précédente
    this.scene.children = this.scene.children.filter(child => 
      !(child.userData && child.userData.isSolutionPath)
    );

    if (!show || this.solutionPath.length === 0) return;

    const pathMaterial = new THREE.MeshBasicMaterial({ 
      color: 0x00FF88,
      transparent: true,
      opacity: 0.6
    });

    this.solutionPath.forEach(({ x, y }) => {
      const pathGeometry = new THREE.RingGeometry(0.3, 0.8);
      const pathMesh = new THREE.Mesh(pathGeometry, pathMaterial);
      pathMesh.position.set(x * 2, 0.05, y * 2);
      pathMesh.rotation.x = -Math.PI / 2;
      pathMesh.userData = { isSolutionPath: true };
      this.scene.add(pathMesh);
    });

    console.log('Solution montrée');
  }

  setupControls() {
    // Événements du clavier
    document.addEventListener('keydown', (e) => {
      this.keys[e.code] = true;
      console.log('Touche appuyée :', e.code);
    });

    document.addEventListener('keyup', (e) => {
      this.keys[e.code] = false;
    });

    console.log('Contrôles configurés');
  }

  update() {
    if (this.gameState !== 'playing' || !this.player) return;

    // Mouvement du joueur
    const originalPos = this.player.position.clone();
    let moved = false;
    let moveDirection = new THREE.Vector3(0, 0, 0);

    if (this.keys['KeyW'] || this.keys['ArrowUp']) {
      this.player.position.z -= this.moveSpeed;
      moveDirection.z = -1;
      moved = true;
    }
    if (this.keys['KeyS'] || this.keys['ArrowDown']) {
      this.player.position.z += this.moveSpeed;
      moveDirection.z = 1;
      moved = true;
    }
    if (this.keys['KeyA'] || this.keys['ArrowLeft']) {
      this.player.position.x -= this.moveSpeed;
      moveDirection.x = -1;
      moved = true;
    }
    if (this.keys['KeyD'] || this.keys['ArrowRight']) {
      this.player.position.x += this.moveSpeed;
      moveDirection.x = 1;
      moved = true;
    }

    // Mettre à jour la direction de vue
    if (moved && (moveDirection.x !== 0 || moveDirection.z !== 0)) {
      this.lastDirection.copy(moveDirection.normalize());
    }

    // Vérifier les collisions
    if (moved) {
      if (this.checkCollision()) {
        this.player.position.copy(originalPos);
      }
    }

    // Mettre à jour la caméra toujours (important pour la première personne)
    this.updateCamera();

    // Vérifier les collisions avec les pièces
    this.checkCoinCollisions();

    // Animer les pièces
    this.animateCoins();

    // Vérifier la victoire
    this.checkLevelCompletion();
  }

  checkCollision() {
    const gridX = Math.round(this.player.position.x / 2);
    const gridZ = Math.round(this.player.position.z / 2);
    
    if (gridX < 0 || gridX >= this.mazeSize || 
        gridZ < 0 || gridZ >= this.mazeSize || 
        this.maze[gridX][gridZ] === 1) {
      return true;
    }
    
    return false;
  }

  checkCoinCollisions() {
    this.coins.forEach(coin => {
      if (!coin.userData.collected) {
        const distance = this.player.position.distanceTo(coin.position);
        if (distance < 1.2) {
          this.collectCoin(coin);
        }
      }
    });
  }

  collectCoin(coin) {
    coin.userData.collected = true;
    this.playerCoins++;
    this.levelProgress[this.currentLevel].coins++;
    
    // Effet de collecte
    this.scene.remove(coin);
    
    // Mettre à jour l'interface utilisateur
    this.updateUI();
    
    console.log(`Pièce collectée ! Total : ${this.playerCoins}`);
  }

  animateCoins() {
    this.coins.forEach(coin => {
      if (!coin.userData.collected) {
        coin.rotation.y += 0.03;
        coin.position.y = coin.userData.originalY + Math.sin(Date.now() * 0.003 + coin.userData.id) * 0.15;
      }
    });
  }

  checkLevelCompletion() {
    const levelConfig = this.levelProgress[this.currentLevel];
    const hasRequiredCoins = levelConfig.coins >= levelConfig.required;
    const gridX = Math.round(this.player.position.x / 2);
    const gridZ = Math.round(this.player.position.z / 2);
    const isAtExit = gridX === this.mazeSize - 2 && gridZ === this.mazeSize - 2;
    
    if (hasRequiredCoins && isAtExit && !levelConfig.completed) {
      this.completeLevel();
    }
  }

  completeLevel() {
    const completionTime = Date.now() - this.startTime;
    this.completionTimes.push(completionTime);
    
    const levelConfig = this.levelProgress[this.currentLevel];
    levelConfig.completed = true;
    
    if (this.currentLevel < this.maxLevel) {
      this.levelProgress[this.currentLevel + 1].unlocked = true;
    }
    
    this.gameState = 'completed';
    this.saveProgress();
    
    this.showLevelCompleteMessage(completionTime);
    
    console.log(`Niveau ${this.currentLevel} complété en ${(completionTime / 1000).toFixed(1)}s`);
  }

  showLevelCompleteMessage(time) {
    const timeStr = (time / 1000).toFixed(1);
    const isLastLevel = this.currentLevel === this.maxLevel;
    
    if (isLastLevel) {
      window.dispatchEvent(new CustomEvent('treasureFound', {
        detail: {
          level: this.currentLevel,
          time: timeStr,
          totalCoins: this.playerCoins
        }
      }));
    } else {
      window.dispatchEvent(new CustomEvent('levelComplete', {
        detail: {
          level: this.currentLevel,
          time: timeStr,
          nextLevel: this.currentLevel + 1
        }
      }));
    }
  }

  nextLevel() {
    if (this.currentLevel < this.maxLevel && this.levelProgress[this.currentLevel + 1].unlocked) {
      this.generateLevel(this.currentLevel + 1);
    }
  }

  updateCamera() {
    if (!this.player) return;

    const targetPos = this.player.position.clone();
    
    if (this.cameraMode === 'firstPerson') {
      // Cacher le personnage en première personne
      this.player.visible = false;
      
      // Vue en première personne - caméra au niveau des yeux
      const eyeHeight = 1.5; // Hauteur des yeux du personnage
      this.camera.position.set(
        targetPos.x,
        targetPos.y + eyeHeight,
        targetPos.z
      );
      
      // Regarder vers l'avant en fonction du dernier mouvement
      const lookAtPoint = new THREE.Vector3(
        targetPos.x + this.lastDirection.x * 5,
        targetPos.y + eyeHeight,
        targetPos.z + this.lastDirection.z * 5
      );
      this.camera.lookAt(lookAtPoint);
      
    } else if (this.cameraMode === 'thirdPerson') {
      // Montrer le personnage en troisième personne
      this.player.visible = true;
      
      this.camera.position.lerp(
        new THREE.Vector3(
          targetPos.x + this.cameraOffset.x,
          targetPos.y + this.cameraOffset.y,
          targetPos.z + this.cameraOffset.z
        ),
        0.1
      );
      this.camera.lookAt(targetPos);
    } else if (this.cameraMode === 'topDown') {
      // Montrer le personnage en vue aérienne
      this.player.visible = true;
      
      this.camera.position.lerp(
        new THREE.Vector3(targetPos.x, targetPos.y + 90, targetPos.z),
        0.1
      );
      this.camera.lookAt(targetPos);
    }
  }

  setCameraMode(mode) {
    this.cameraMode = mode;
    console.log('Mode de caméra :', mode);
  }

  clearLevel() {
    const objectsToRemove = [];
    this.scene.traverse(child => {
      if (child.isMesh && child !== this.player) {
        objectsToRemove.push(child);
      }
    });
    
    objectsToRemove.forEach(obj => {
      this.scene.remove(obj);
    });
    
    this.coins = [];
    this.solutionPath = [];
  }

  saveProgress() {
    localStorage.setItem('kaamelottMazeProgress', JSON.stringify({
      levelProgress: this.levelProgress,
      currentLevel: this.currentLevel,
      playerCoins: this.playerCoins,
      completionTimes: this.completionTimes
    }));
  }

  loadProgress() {
    const saved = localStorage.getItem('kaamelottMazeProgress');
    if (saved) {
      const data = JSON.parse(saved);
      this.levelProgress = data.levelProgress || this.levelProgress;
      this.currentLevel = data.currentLevel || 1;
      this.playerCoins = data.playerCoins || 0;
      this.completionTimes = data.completionTimes || [];
    }
  }

  updateUI() {
    const event = new CustomEvent('mazeUIUpdate', {
      detail: {
        currentLevel: this.currentLevel,
        maxLevel: this.maxLevel,
        coins: this.levelProgress[this.currentLevel].coins,
        requiredCoins: this.levelProgress[this.currentLevel].required,
        totalCoins: this.playerCoins,
        levelProgress: this.levelProgress
      }
    });
    window.dispatchEvent(event);
  }

  animate() {
    requestAnimationFrame(() => this.animate());
    
    this.update();
    
    if (this.renderer && this.scene && this.camera) {
      this.renderer.render(this.scene, this.camera);
    }
  }

  onResize() {
    if (!this.camera || !this.renderer) return;
    
    this.camera.aspect = this.container.clientWidth / this.container.clientHeight;
    this.camera.updateProjectionMatrix();
    this.renderer.setSize(this.container.clientWidth, this.container.clientHeight);
  }

  reset() {
    this.generateLevel(this.currentLevel);
  }
}

// Exporter pour utilisation globale
window.MazeGame3D = MazeGame3D;
```

## c:\Users\rexma\Desktop\Les Chevalier du commit\Les-Chevaliers-du-Commit\script.js
```
// script.js - Version corrigée et simplifiée en français

// Variables globales pour Leaflet
let map;
let kaamelottMarker, labyrinthMarker;
let waypoints = [];
let waypointMarkers = [];
let routingControl;
let customRoute;

// Variable pour le labyrinthe 3D
let mazeGame3D;

// Coordonnées
const kaamelottCoords = [43.3124, -0.3668];
const labyrinthCoords = [43.2933, -0.3708];

const predefinedWaypoints = [
  [43.305, -0.365, "Place Verdun", "🏛️"],
  [43.298, -0.372, "Université de Pau", "🎓"],
  [43.31, -0.36, "Parc Lawrence", "🌳"],
  [43.3, -0.368, "Centre-ville de Pau", "🏪"],
  [43.315, -0.372, "Boulevard des Pyrénées", "🏔️"],
  [43.308, -0.359, "Stade du Hameau", "⚽"],
  [43.295, -0.375, "Gare SNCF de Pau", "🚂"],
];

// ============= INITIALISATION =============

window.onload = function () {
  console.log('Initialisation de l\'application...');
  initMap();
  setupMazeEventListeners();
};

// ============= FONCTIONS DE CARTE =============

function initMap() {
  map = L.map("map").setView([43.3028, -0.3678], 14);

  const osmLayer = L.tileLayer(
    "https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png",
    {
      attribution: "© Contributeurs OpenStreetMap",
      maxZoom: 19,
    }
  );

  const cartoLayer = L.tileLayer(
    "https://{s}.basemaps.cartocdn.com/rastertiles/voyager/{z}/{x}/{y}{r}.png",
    {
      attribution: "© CARTO © Contributeurs OpenStreetMap",
      maxZoom: 19,
    }
  );

  osmLayer.addTo(map);

  const baseMaps = {
    OpenStreetMap: osmLayer,
    "CartoDB Voyager": cartoLayer,
  };
  L.control.layers(baseMaps).addTo(map);

  const kaamelottIcon = L.divIcon({
    html: '<div style="background: linear-gradient(45deg, #32CD32, #228B22); border: 3px solid #FFD700; border-radius: 50%; width: 40px; height: 40px; display: flex; align-items: center; justify-content: center; font-size: 20px; box-shadow: 0 0 15px rgba(50, 205, 50, 0.7);">🏰</div>',
    iconSize: [40, 40],
    iconAnchor: [20, 20],
    popupAnchor: [0, -20],
    className: "custom-marker",
  });

  const labyrinthIcon = L.divIcon({
    html: '<div style="background: linear-gradient(45deg, #FF6B6B, #FF4444); border: 3px solid #FFD700; border-radius: 50%; width: 40px; height: 40px; display: flex; align-items: center; justify-content: center; font-size: 20px; box-shadow: 0 0 15px rgba(255, 107, 107, 0.7);">🌀</div>',
    iconSize: [40, 40],
    iconAnchor: [20, 20],
    popupAnchor: [0, -20],
    className: "custom-marker",
  });

  kaamelottMarker = L.marker(kaamelottCoords, { icon: kaamelottIcon })
    .addTo(map)
    .bindPopup(`
      <div style="text-align: center;">
        <h3>🏰 Kaamelott</h3>
        <p><strong>Pôle Lahérrère, Pau</strong></p>
        <p>Point de départ de la quête</p>
      </div>
    `);

  labyrinthMarker = L.marker(labyrinthCoords, { icon: labyrinthIcon })
    .addTo(map)
    .bindPopup(`
      <div style="text-align: center;">
        <h3>🌀 Entrée du Labyrinthe</h3>
        <p><strong>Château de Pau</strong></p>
        <p>Destination finale</p>
      </div>
    `);

  L.circle(kaamelottCoords, {
    color: "#32CD32",
    fillColor: "#32CD32",
    fillOpacity: 0.1,
    radius: 200,
  }).addTo(map);

  L.circle(labyrinthCoords, {
    color: "#FF6B6B",
    fillColor: "#FF6B6B",
    fillOpacity: 0.1,
    radius: 200,
  }).addTo(map);

  predefinedWaypoints.slice(0, 3).forEach((wp) => {
    addWaypointAt(wp[0], wp[1], wp[2], wp[3]);
  });

  console.log('Carte initialisée correctement');
}

function showPhase(phase) {
  console.log('Changement vers la phase:', phase);
  
  document.querySelectorAll(".phase-btn").forEach((btn) => btn.classList.remove("active"));
  document.querySelectorAll('[id$="-container"]').forEach((container) => container.classList.remove("active"));

  event.target.classList.add("active");
  document.getElementById(phase + "-container").classList.add("active");

  if (phase === "map" && map) {
    setTimeout(() => map.invalidateSize(), 100);
  } else if (phase === "maze") {
    if (!mazeGame3D) {
      console.log('Initialisation du labyrinthe 3D pour la première fois...');
      initMaze3D();
    } else {
      console.log('Le labyrinthe 3D existe déjà');
    }
  }
}

function addWaypoint() {
  if (waypoints.length < predefinedWaypoints.length) {
    const wp = predefinedWaypoints[waypoints.length];
    addWaypointAt(wp[0], wp[1], wp[2], wp[3]);
    updateStatus("map", `Point de passage "${wp[2]}" ajouté !`, "success");
  } else {
    updateStatus("map", "Tous les points de passage ont été ajoutés !", "info");
  }
}

function addWaypointAt(lat, lng, name, emoji) {
  const waypointIcon = L.divIcon({
    html: `<div style="background: linear-gradient(45deg, #FFD700, #FFA500); border: 3px solid #DAA520; border-radius: 50%; width: 35px; height: 35px; display: flex; align-items: center; justify-content: center; font-size: 16px; box-shadow: 0 0 12px rgba(255, 215, 0, 0.7);">${emoji}</div>`,
    iconSize: [35, 35],
    iconAnchor: [17, 17],
    popupAnchor: [0, -17],
    className: "custom-marker",
  });

  const marker = L.marker([lat, lng], { icon: waypointIcon })
    .addTo(map)
    .bindPopup(`
      <div style="text-align: center;">
        <h4>${emoji} ${name}</h4>
        <p>Point de passage #${waypoints.length + 1}</p>
      </div>
    `);

  waypoints.push({ marker, coords: [lat, lng], name, emoji });
  waypointMarkers.push(marker);

  L.circle([lat, lng], {
    color: "#FFD700",
    fillColor: "#FFD700",
    fillOpacity: 0.1,
    radius: 100,
  }).addTo(map);
}

function findShortestPath() {
  if (waypoints.length === 0) {
    updateStatus("map", "Ajoutez au moins un point de passage !", "error");
    return;
  }

  updateStatus("map", "Calcul du chemin optimal...", "loading");
  clearPath();

  setTimeout(() => {
    let routeWaypoints = [L.latLng(kaamelottCoords[0], kaamelottCoords[1])];
    let unvisitedWaypoints = [...waypoints];
    let currentPos = kaamelottCoords;

    while (unvisitedWaypoints.length > 0) {
      let nearest = unvisitedWaypoints[0];
      let nearestIndex = 0;
      let minDistance = calculateDistance(currentPos, nearest.coords);

      for (let i = 1; i < unvisitedWaypoints.length; i++) {
        let distance = calculateDistance(currentPos, unvisitedWaypoints[i].coords);
        if (distance < minDistance) {
          minDistance = distance;
          nearest = unvisitedWaypoints[i];
          nearestIndex = i;
        }
      }

      routeWaypoints.push(L.latLng(nearest.coords[0], nearest.coords[1]));
      currentPos = nearest.coords;
      unvisitedWaypoints.splice(nearestIndex, 1);
    }

    routeWaypoints.push(L.latLng(labyrinthCoords[0], labyrinthCoords[1]));

    routingControl = L.Routing.control({
      waypoints: routeWaypoints,
      routeWhileDragging: false,
      addWaypoints: false,
      createMarker: () => null,
      lineOptions: {
        styles: [{ color: "#4169E1", weight: 6, opacity: 0.8, dashArray: "10, 5" }]
      },
      show: true,
      collapsible: true,
      router: L.Routing.osrmv1({
        serviceUrl: "https://router.project-osrm.org/route/v1",
        profile: "walking"
      })
    }).addTo(map);

    routingControl.on("routesfound", (e) => {
      const routes = e.routes;
      const summary = routes[0].summary;
      const distance = (summary.totalDistance / 1000).toFixed(2);
      const time = Math.round(summary.totalTime / 60);
      updateStatus("map", `🎯 Chemin calculé ! Distance: ${distance} km | Temps: ${time} min`, "success");
    });

    routingControl.on("routingerror", () => {
      updateStatus("map", "Erreur - Utilisation du chemin direct", "error");
      createManualRoute(routeWaypoints);
    });
  }, 1000);
}

function createManualRoute(waypoints) {
  const pathCoords = waypoints.map((wp) => [wp.lat, wp.lng]);
  customRoute = L.polyline(pathCoords, {
    color: "#4169E1",
    weight: 6,
    opacity: 0.8,
    dashArray: "10, 5"
  }).addTo(map);

  let totalDistance = 0;
  for (let i = 0; i < pathCoords.length - 1; i++) {
    totalDistance += calculateDistance(pathCoords[i], pathCoords[i + 1]);
  }
  updateStatus("map", `Chemin calculé ! Distance: ${totalDistance.toFixed(2)} km`, "success");
}

function clearPath() {
  if (routingControl) {
    map.removeControl(routingControl);
    routingControl = null;
  }
  if (customRoute) {
    map.removeLayer(customRoute);
    customRoute = null;
  }
}

function calculateDistance(coord1, coord2) {
  const latlng1 = L.latLng(coord1[0], coord1[1]);
  const latlng2 = L.latLng(coord2[0], coord2[1]);
  return latlng1.distanceTo(latlng2) / 1000;
}

function centerOnKaamelott() {
  map.setView(kaamelottCoords, 15);
  kaamelottMarker.openPopup();
}

// ============= LABYRINTHE 3D =============

function initMaze3D() {
  console.log('Appel à initMaze3D...');
  updateStatus("maze", "Chargement du labyrinthe 3D...", "loading");
  
  const mazeContainer = document.getElementById("maze");
  
  if (!mazeContainer) {
    console.error('Le conteneur #maze n\'a pas été trouvé');
    return;
  }
  
  try {
    mazeGame3D = new MazeGame3D(mazeContainer);
    updateMazeControls();
    updateStatus("maze", "¡Labyrinthe 3D prêt ! Utilisez WASD pour vous déplacer", "success");
    console.log('Labyrinthe 3D initialisé correctement');
  } catch (error) {
    console.error('Erreur lors de l\'initialisation du labyrinthe:', error);
    updateStatus("maze", "Erreur lors du chargement du labyrinthe 3D", "error");
  }
}

function updateMazeControls() {
  const controlsContainer = document.querySelector('#maze-container .controls');
  if (!controlsContainer) return;
  
  controlsContainer.innerHTML = `
    <button class="control-btn" onclick="generateMaze()">🔄 Réinitialiser Niveau</button>
    <button class="control-btn" onclick="solveMaze()">🧭 Montrer Solution</button>
    <button class="control-btn" onclick="toggleCameraMode()">📷 Changer Vue</button>
    <button class="control-btn" onclick="nextLevel()" id="next-level-btn" style="display: none;">⏭️ Niveau Suivant</button>
    <button class="control-btn" onclick="resetProgress()">🗑️ Reset Progrès</button>
  `;

  updateMazeInfoPanel();
}

function updateMazeInfoPanel() {
  const infoPanelContainer = document.querySelector('#maze-container .info-panel');
  if (!infoPanelContainer) return;
  
  infoPanelContainer.innerHTML = `
    <div id="maze-status" class="status">¡Explorez le labyrinthe 3D ! Utilisez WASD ou les flèches pour vous déplacer</div>
    
    <div class="level-progress">
      <div class="progress-header">
        <span id="level-indicator">Niveau 1/5</span>
        <span id="coins-counter">💰 0/5</span>
      </div>
      <div class="progress-bar-container">
        <div class="progress-bar" id="progress-bar"></div>
      </div>
    </div>

    <div class="game-stats">
      <div class="stat-item">
        <span class="stat-label">Temps :</span>
        <span class="stat-value" id="timer">00:00</span>
      </div>
      <div class="stat-item">
        <span class="stat-label">Pièces totales :</span>
        <span class="stat-value" id="total-coins">0</span>
      </div>
    </div>

    <div class="controls-help">
      <h4>🎮 Contrôles</h4>
      <div class="control-item"><kbd>WASD</kbd> ou <kbd>↑↓←→</kbd> - Déplacer Arthur</div>
      <div class="control-item"><kbd>📷</kbd> - Changer vue (1ère personne / 3ème personne / Aérienne)</div>
    </div>

    <div class="legend">
      <div class="legend-item">
        <div class="legend-color" style="background: #FFD700;"></div>
        <span>Arthur / Pièces</span>
      </div>
      <div class="legend-item">
        <div class="legend-color" style="background: #00FF88;"></div>
        <span>Solution</span>
      </div>
      <div class="legend-item">
        <div class="legend-color" style="background: #8B4513;"></div>
        <span>Murs</span>
      </div>
    </div>
  `;
}

function generateMaze() {
  console.log('Appel à generateMaze...');
  if (mazeGame3D) {
    mazeGame3D.reset();
    updateStatus("maze", "¡Niveau réinitialisé !", "success");
  } else {
    initMaze3D();
  }
}

function solveMaze() {
  console.log('Appel à solveMaze...');
  if (mazeGame3D) {
    mazeGame3D.showSolution(true);
    updateStatus("maze", "Solution montrée en vert", "success");
    
    setTimeout(() => {
      mazeGame3D.showSolution(false);
      updateStatus("maze", "Solution cachée. Essayez maintenant !", "info");
    }, 5000);
  }
}

function toggleCameraMode() {
  console.log('Appel à toggleCameraMode...');
  if (mazeGame3D) {
    const currentMode = mazeGame3D.cameraMode;
    let newMode, modeText;
    
    // Cycle : première personne -> troisième personne -> vue aérienne -> première personne
    if (currentMode === 'firstPerson') {
      newMode = 'thirdPerson';
      modeText = '👤 Troisième Personne';
    } else if (currentMode === 'thirdPerson') {
      newMode = 'topDown';
      modeText = '🦅 Vue Aérienne';
    } else {
      newMode = 'firstPerson';
      modeText = '👁️ Première Personne';
    }
    
    mazeGame3D.setCameraMode(newMode);
    updateStatus("maze", `Vue changée vers ${modeText}`, "info");
  }
}

function nextLevel() {
  console.log('Appel à nextLevel...');
  if (mazeGame3D) {
    mazeGame3D.nextLevel();
    document.getElementById('next-level-btn').style.display = 'none';
  }
}

function resetProgress() {
  if (confirm('Êtes-vous sûr de réinitialiser tout le progrès ?')) {
    localStorage.removeItem('kaamelottMazeProgress');
    location.reload();
  }
}

// ============= ÉVÉNEMENTS =============

function setupMazeEventListeners() {
  console.log('Configuration des écouteurs d\'événements du labyrinthe...');
  
  window.addEventListener('mazeUIUpdate', (event) => {
    const data = event.detail;
    
    const levelIndicator = document.getElementById('level-indicator');
    const coinsCounter = document.getElementById('coins-counter');
    const totalCoins = document.getElementById('total-coins');
    const progressBar = document.getElementById('progress-bar');
    
    if (levelIndicator) levelIndicator.textContent = `Niveau ${data.currentLevel}/${data.maxLevel}`;
    if (coinsCounter) coinsCounter.textContent = `💰 ${data.coins}/${data.requiredCoins}`;
    if (totalCoins) totalCoins.textContent = data.totalCoins;
    if (progressBar) progressBar.style.width = `${(data.coins / data.requiredCoins) * 100}%`;
  });

  window.addEventListener('levelComplete', (event) => {
    const data = event.detail;
    updateStatus("maze", `🎉 Niveau ${data.level} complété en ${data.time}s !`, "success");
    
    const nextBtn = document.getElementById('next-level-btn');
    if (nextBtn) nextBtn.style.display = 'inline-block';
    
    setTimeout(() => nextLevel(), 3000);
  });

  window.addEventListener('treasureFound', (event) => {
    const data = event.detail;
    updateStatus("maze", `🏆 FÉLICITATIONS ! Vous avez complété tous les niveaux avec ${data.totalCoins} pièces !`, "success");
    showFinalVictoryMessage(data);
  });
}

function showFinalVictoryMessage(data) {
  const mazeStatus = document.getElementById('maze-status');
  if (!mazeStatus) return;
  
  mazeStatus.innerHTML = `
    <div class="final-victory">
      <h2>🏆 QUÊTE COMPLÈTE !</h2>
      <p>Arthur a trouvé le trésor de la Dame du Lac !</p>
      <div class="victory-stats">
        <div class="victory-stat"><strong>Temps :</strong> ${data.time}s</div>
        <div class="victory-stat"><strong>Pièces :</strong> ${data.totalCoins}</div>
        <div class="victory-stat"><strong>Niveaux :</strong> 5/5</div>
      </div>
      <button class="control-btn" onclick="resetProgress()">🔄 Rejouer</button>
    </div>
  `;
  mazeStatus.className = 'status victory';
}

let gameTimer;

function startGameTimer() {
  if (gameTimer) clearInterval(gameTimer);
  
  const startTime = Date.now();
  gameTimer = setInterval(() => {
    const elapsed = Date.now() - startTime;
    const seconds = Math.floor(elapsed / 1000);
    const minutes = Math.floor(seconds / 60);
    const displaySeconds = seconds % 60;
    
    const timerElement = document.getElementById('timer');
    if (timerElement) {
      timerElement.textContent = `${minutes.toString().padStart(2, '0')}:${displaySeconds.toString().padStart(2, '0')}`;
    }
  }, 1000);
}

function updateStatus(phase, message, type = "info") {
  const statusElement = document.getElementById(phase + "-status");
  if (statusElement) {
    statusElement.textContent = message;
    statusElement.className = "status " + type;
  }
  console.log(`Status [${phase}]:`, message);
}

window.addEventListener('mazeUIUpdate', () => {
  if (!gameTimer) startGameTimer();
});
```

## c:\Users\rexma\Desktop\Les Chevalier du commit\Les-Chevaliers-du-Commit\style.css
```
/* style.css - Versión completa con sistema 3D integrado */

* {
  margin: 0;
  padding: 0;
  box-sizing: border-box;
}

body {
  font-family: "Cinzel", serif;
  background: linear-gradient(135deg, #2c1810 0%, #8b4513 50%, #daa520 100%);
  color: #ffd700;
  min-height: 100vh;
}

.container {
  max-width: 1200px;
  margin: 0 auto;
  padding: 20px;
}

h1 {
  text-align: center;
  font-size: 2.5em;
  margin-bottom: 20px;
  text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
  color: #ffd700;
}

.quest-info {
  background: rgba(0, 0, 0, 0.7);
  padding: 20px;
  border-radius: 15px;
  margin-bottom: 20px;
  border: 2px solid #daa520;
}

/* ============= NAVEGACIÓN DE FASES ============= */

.phase-selector {
  display: flex;
  gap: 20px;
  margin-bottom: 20px;
  justify-content: center;
}

.phase-btn {
  padding: 15px 30px;
  background: linear-gradient(45deg, #8b4513, #daa520);
  color: white;
  border: none;
  border-radius: 25px;
  cursor: pointer;
  font-size: 1.1em;
  font-weight: bold;
  transition: all 0.3s ease;
  box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
}

.phase-btn:hover {
  transform: translateY(-2px);
  box-shadow: 0 6px 20px rgba(0, 0, 0, 0.4);
}

.phase-btn.active {
  background: linear-gradient(45deg, #daa520, #ffd700);
  color: #2c1810;
}

/* ============= CONTENEDORES DE FASES ============= */

#map-container,
#maze-container {
  display: none;
}

#map-container.active,
#maze-container.active {
  display: block;
}

/* ============= MAPA (MANTENIDO) ============= */

#map {
  height: 600px;
  border-radius: 15px;
  border: 3px solid #daa520;
  box-shadow: 0 8px 25px rgba(0, 0, 0, 0.3);
}

/* ============= LABERINTO 3D ============= */

#maze {
  height: 600px;
  border-radius: 15px;
  border: 3px solid #daa520;
  box-shadow: 0 8px 25px rgba(0, 0, 0, 0.3);
  background: #1a1a2e;
  position: relative;
  overflow: hidden;
}

#maze canvas {
  border-radius: 12px;
  display: block;
}

/* ============= CONTROLES ============= */

.controls {
  margin-top: 20px;
  display: flex;
  gap: 15px;
  justify-content: center;
  flex-wrap: wrap;
}

.control-btn {
  padding: 12px 25px;
  background: linear-gradient(45deg, #2c1810, #8b4513);
  color: #ffd700;
  border: 2px solid #daa520;
  border-radius: 20px;
  cursor: pointer;
  font-weight: bold;
  transition: all 0.3s ease;
  font-size: 0.9em;
  text-decoration: none;
  display: inline-block;
}

.control-btn:hover {
  background: linear-gradient(45deg, #8b4513, #daa520);
  transform: scale(1.05);
  box-shadow: 0 4px 15px rgba(218, 165, 32, 0.3);
}

.control-btn:active {
  transform: scale(0.98);
}

/* ============= PANEL DE INFORMACIÓN ============= */

.info-panel {
  background: rgba(0, 0, 0, 0.8);
  padding: 20px;
  border-radius: 10px;
  margin-top: 20px;
  border: 2px solid #daa520;
}

/* ============= PROGRESO DE NIVEL ============= */

.level-progress {
  background: rgba(218, 165, 32, 0.1);
  border: 2px solid #daa520;
  border-radius: 10px;
  padding: 15px;
  margin: 15px 0;
}

.progress-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 10px;
}

#level-indicator {
  font-size: 1.2em;
  font-weight: bold;
  color: #ffd700;
}

#coins-counter {
  font-size: 1.1em;
  color: #ffd700;
  animation: coinPulse 2s ease-in-out infinite;
}

.progress-bar-container {
  width: 100%;
  height: 8px;
  background: rgba(0, 0, 0, 0.5);
  border-radius: 4px;
  overflow: hidden;
}

.progress-bar {
  height: 100%;
  background: linear-gradient(90deg, #32cd32, #ffd700);
  border-radius: 4px;
  transition: width 0.5s ease;
  min-width: 2px;
}

/* ============= ESTADÍSTICAS DEL JUEGO ============= */

.game-stats {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
  gap: 15px;
  margin: 15px 0;
  padding: 15px;
  background: rgba(44, 24, 16, 0.6);
  border-radius: 8px;
  border: 1px solid #8b4513;
}

.stat-item {
  text-align: center;
}

.stat-label {
  display: block;
  font-size: 0.9em;
  color: #daa520;
  margin-bottom: 5px;
}

.stat-value {
  display: block;
  font-size: 1.3em;
  font-weight: bold;
  color: #ffd700;
}

#timer {
  font-family: 'Courier New', monospace;
  background: rgba(0, 0, 0, 0.5);
  padding: 5px 10px;
  border-radius: 5px;
  border: 1px solid #daa520;
}

/* ============= AYUDA DE CONTROLES ============= */

.controls-help {
  margin: 15px 0;
  padding: 15px;
  background: rgba(65, 105, 225, 0.1);
  border: 1px solid #4169e1;
  border-radius: 8px;
}

.controls-help h4 {
  color: #4169e1;
  margin-bottom: 10px;
  font-size: 1.1em;
}

.control-item {
  display: flex;
  align-items: center;
  gap: 10px;
  margin: 5px 0;
  font-size: 0.9em;
}

.control-item kbd {
  background: #2c1810;
  color: #ffd700;
  padding: 3px 8px;
  border-radius: 4px;
  border: 1px solid #8b4513;
  font-family: 'Courier New', monospace;
  font-size: 0.8em;
  box-shadow: inset 0 -2px 0 rgba(0, 0, 0, 0.3);
}

/* ============= LEYENDA ============= */

.legend {
  display: flex;
  gap: 20px;
  justify-content: center;
  flex-wrap: wrap;
  margin-top: 15px;
  padding-top: 15px;
  border-top: 1px solid #8b4513;
}

.legend-item {
  display: flex;
  align-items: center;
  gap: 8px;
  font-size: 0.9em;
}

.legend-color {
  width: 20px;
  height: 20px;
  border: 1px solid #daa520;
  border-radius: 3px;
  flex-shrink: 0;
}

/* ============= ESTADOS Y MENSAJES ============= */

.status {
  text-align: center;
  font-size: 1.1em;
  margin-top: 15px;
  font-weight: bold;
  padding: 10px;
  border-radius: 8px;
  transition: all 0.3s ease;
}

.status.success {
  color: #32cd32;
  background: rgba(50, 205, 50, 0.1);
  border: 1px solid #32cd32;
}

.status.error {
  color: #ff6b6b;
  background: rgba(255, 107, 107, 0.1);
  border: 1px solid #ff6b6b;
}

.status.loading {
  color: #4169e1;
  background: rgba(65, 105, 225, 0.1);
  border: 1px solid #4169e1;
  animation: pulse 1.5s ease-in-out infinite;
}

.status.info {
  color: #ffd700;
  background: rgba(255, 215, 0, 0.1);
  border: 1px solid #ffd700;
}

.status.victory {
  background: linear-gradient(45deg, rgba(50, 205, 50, 0.2), rgba(255, 215, 0, 0.2));
  border: 2px solid #32cd32;
  animation: victoryGlow 2s ease-in-out infinite;
}

/* ============= MENSAJE DE VICTORIA FINAL ============= */

.final-victory {
  text-align: center;
  padding: 30px;
  background: linear-gradient(135deg, rgba(50, 205, 50, 0.2), rgba(255, 215, 0, 0.2));
  border: 3px solid #32cd32;
  border-radius: 15px;
  margin: 20px 0;
  animation: finalVictoryPulse 3s ease-in-out infinite;
}

.final-victory h2 {
  font-size: 2.5em;
  color: #ffd700;
  text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
  margin-bottom: 15px;
}

.victory-stats {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
  gap: 15px;
  margin: 20px 0;
}

.victory-stat {
  padding: 10px;
  background: rgba(0, 0, 0, 0.3);
  border-radius: 8px;
  border: 1px solid #daa520;
}

.victory-stat strong {
  color: #32cd32;
}

/* ============= LABERINTO 2D (LEGACY - Por si acaso) ============= */

.maze-cell {
  width: 25px;
  height: 25px;
  border: 1px solid #444;
  transition: all 0.3s ease;
}

.maze-cell.wall {
  background: #2c1810;
  box-shadow: inset 0 0 10px rgba(0, 0, 0, 0.8);
}

.maze-cell.path {
  background: #f5f5dc;
}

.maze-cell.start {
  background: #32cd32;
  box-shadow: 0 0 15px #32cd32;
}

.maze-cell.end {
  background: #ffd700;
  box-shadow: 0 0 15px #ffd700;
}

.maze-cell.arthur {
  background: #4169e1;
  box-shadow: 0 0 20px #4169e1;
  border-radius: 50%;
}

.maze-cell.visited {
  background: #98fb98;
  opacity: 0.7;
}

.maze-cell.solution {
  background: #ff6b6b;
  box-shadow: 0 0 10px #ff6b6b;
}

/* ============= ESTILOS LEAFLET (MANTENIDOS) ============= */

.leaflet-routing-container {
  background: rgba(0, 0, 0, 0.8) !important;
  color: #ffd700 !important;
  border: 2px solid #daa520 !important;
  border-radius: 10px !important;
  font-family: "Cinzel", serif !important;
}

.leaflet-routing-container h2 {
  color: #ffd700 !important;
}

.leaflet-routing-container h3 {
  color: #daa520 !important;
}

.leaflet-popup-content-wrapper {
  background: rgba(0, 0, 0, 0.9) !important;
  color: #ffd700 !important;
  border: 2px solid #daa520 !important;
  border-radius: 10px !important;
}

.leaflet-popup-content {
  color: #ffd700 !important;
  font-family: "Cinzel", serif !important;
}

.custom-icon {
  background: transparent !important;
  border: none !important;
  text-align: center !important;
  font-size: 24px !important;
  filter: drop-shadow(2px 2px 4px rgba(0, 0, 0, 0.8));
}

/* ============= ANIMACIONES ============= */

@keyframes pulse {
  0%, 100% { opacity: 1; }
  50% { opacity: 0.7; }
}

@keyframes coinPulse {
  0%, 100% { transform: scale(1); }
  50% { transform: scale(1.05); }
}

@keyframes victoryGlow {
  0%, 100% { 
    box-shadow: 0 0 20px rgba(50, 205, 50, 0.5);
    border-color: #32cd32;
  }
  50% { 
    box-shadow: 0 0 30px rgba(255, 215, 0, 0.7);
    border-color: #ffd700;
  }
}

@keyframes finalVictoryPulse {
  0%, 100% { 
    transform: scale(1);
    filter: brightness(1);
  }
  33% { 
    transform: scale(1.02);
    filter: brightness(1.1);
  }
  66% { 
    transform: scale(1.01);
    filter: brightness(1.05);
  }
}

@keyframes slideInFromRight {
  from {
    transform: translateX(100%);
    opacity: 0;
  }
  to {
    transform: translateX(0);
    opacity: 1;
  }
}

/* ============= RESPONSIVE DESIGN ============= */

@media (max-width: 768px) {
  .container {
    padding: 10px;
  }
  
  h1 {
    font-size: 2em;
  }
  
  .phase-selector {
    flex-direction: column;
    align-items: center;
    gap: 10px;
  }
  
  .phase-btn {
    width: 100%;
    max-width: 300px;
  }
  
  #map, #maze {
    height: 400px;
  }
  
  .controls {
    flex-direction: column;
    align-items: center;
  }
  
  .control-btn {
    width: 100%;
    max-width: 250px;
    margin: 5px 0;
  }
  
  .game-stats {
    grid-template-columns: 1fr 1fr;
  }
  
  .legend {
    flex-direction: column;
    align-items: center;
    gap: 10px;
  }
  
  .final-victory h2 {
    font-size: 2em;
  }
  
  .victory-stats {
    grid-template-columns: 1fr;
  }
}

@media (max-width: 480px) {
  h1 {
    font-size: 1.5em;
  }
  
  #map, #maze {
    height: 300px;
  }
  
  .info-panel {
    padding: 15px;
  }
  
  .quest-info {
    padding: 15px;
  }
  
  .game-stats {
    grid-template-columns: 1fr;
    gap: 10px;
  }
  
  .progress-header {
    flex-direction: column;
    gap: 5px;
  }
  
  .controls-help {
    padding: 10px;
  }
  
  .control-item {
    flex-direction: column;
    align-items: flex-start;
    gap: 5px;
  }
}

/* ============= MEJORAS DE ACCESIBILIDAD ============= */

@media (prefers-reduced-motion: reduce) {
  * {
    animation-duration: 0.01ms !important;
    animation-iteration-count: 1 !important;
    transition-duration: 0.01ms !important;
  }
}

.control-btn:focus,
.phase-btn:focus {
  outline: 2px solid #ffd700;
  outline-offset: 2px;
}

/* ============= MODO ALTO CONTRASTE ============= */

@media (prefers-contrast: high) {
  .status.success {
    background: #000;
    color: #0f0;
    border: 2px solid #0f0;
  }
  
  .status.error {
    background: #000;
    color: #f00;
    border: 2px solid #f00;
  }
  
  .control-btn {
    background: #000;
    color: #ffd700;
    border: 2px solid #ffd700;
  }
  
  .phase-btn {
    background: #000;
    color: #ffd700;
    border: 2px solid #ffd700;
  }
}

/* ============= TRANSICIONES SUAVES ============= */

.info-panel,
.level-progress,
.game-stats,
.controls-help {
  transition: all 0.3s ease;
}

.info-panel:hover {
  transform: translateY(-2px);
  box-shadow: 0 6px 15px rgba(218, 165, 32, 0.3);
}

/* ============= EFECTOS ESPECIALES ============= */

.control-btn.next-level {
  background: linear-gradient(45deg, #32cd32, #228b22);
  animation: slideInFromRight 0.5s ease;
}

.control-btn.next-level:hover {
  background: linear-gradient(45deg, #228b22, #32cd32);
  box-shadow: 0 0 20px rgba(50, 205, 50, 0.5);
}

/* ============= PERSONALIZACIÓN DEL SCROLLBAR ============= */

::-webkit-scrollbar {
  width: 8px;
}

::-webkit-scrollbar-track {
  background: rgba(44, 24, 16, 0.5);
  border-radius: 4px;
}

::-webkit-scrollbar-thumb {
  background: linear-gradient(180deg, #daa520, #8b4513);
  border-radius: 4px;
}

::-webkit-scrollbar-thumb:hover {
  background: linear-gradient(180deg, #ffd700, #daa520);
}
```

## c:\Users\rexma\Desktop\Les Chevalier du commit\Les-Chevaliers-du-Commit\data.js
```
// Lieux et chemins du royaume
export const lieux = {
  Kaamelott: {
    lat: 48.8566,
    lng: 2.3522,
    nom: "Kaamelott",
    icone: "castle",
    description: "Château du Roi Arthur.",
  },
  PontRivière: {
    lat: 48.8606,
    lng: 2.3376,
    nom: "Pont de la Rivière",
    icone: "bridge",
    description: "Pont ancien gardé par des chevaliers.",
  },
  ForêtBrume: {
    lat: 48.8534,
    lng: 2.3488,
    nom: "Forêt des Brumes",
    icone: "tree",
    description: "Forêt mystérieuse, attention aux créatures...",
  },
  CollineCorbeaux: {
    lat: 48.848,
    lng: 2.33,
    nom: "Colline aux Corbeaux",
    icone: "crow",
    description: "Lieu de rassemblement des corbeaux messagers.",
  },
  EntréeLabyrinthe: {
    lat: 48.8584,
    lng: 2.2945,
    nom: "Entrée du Labyrinthe",
    icone: "door-open",
    description: "Ici commence l’épreuve finale.",
  },
};

export const chemins = [
  ["Kaamelott", "PontRivière", 1.2],
  ["Kaamelott", "ForêtBrume", 1.8],
  ["PontRivière", "CollineCorbeaux", 0.8],
  ["PontRivière", "EntréeLabyrinthe", 1.5],
  ["ForêtBrume", "CollineCorbeaux", 0.5],
  ["ForêtBrume", "EntréeLabyrinthe", 1.0],
  ["CollineCorbeaux", "EntréeLabyrinthe", 0.7],
];

export const graphe = {
  Kaamelott: { PontRivière: 1.2, ForêtBrume: 1.8 },
  PontRivière: { Kaamelott: 1.2, CollineCorbeaux: 0.8, EntréeLabyrinthe: 1.5 },
  ForêtBrume: { Kaamelott: 1.8, CollineCorbeaux: 0.5, EntréeLabyrinthe: 1.0 },
  CollineCorbeaux: { PontRivière: 0.8, ForêtBrume: 0.5, EntréeLabyrinthe: 0.7 },
  EntréeLabyrinthe: {},
};

```

## c:\Users\rexma\Desktop\Les Chevalier du commit\Les-Chevaliers-du-Commit\index.html
```
<!DOCTYPE html>
<html lang="fr">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Quête de Kaamelott - La Recherche du Trésor</title>
    <link rel="stylesheet" href="style.css">
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <link rel="stylesheet" href="https://unpkg.com/leaflet-routing-machine@3.2.12/dist/leaflet-routing-machine.css" />
</head>

<body>
    <div class="container">
        <h1>⚔️ Quête de Kaamelott ⚔️</h1>

        <div class="quest-info">
            <p><strong>Mission :</strong> Aider le roi Arthur à trouver l'entrée du labyrinthe, puis le guider vers le
                trésor mystérieux de la Dame du Lac à travers 5 niveaux progressifs!</p>
        </div>

        <div class="phase-selector">
            <button class="phase-btn active" onclick="showPhase('map')">🗺️ Carte du Royaume</button>
            <button class="phase-btn" onclick="showPhase('maze')">🏰 Labyrinthe 3D</button>
        </div>

        <div id="map-container" class="active">
            <div id="map"></div>
            <div class="controls">
                <button class="control-btn" onclick="findShortestPath()">🧭 Calculer Route Optimale</button>
                <button class="control-btn" onclick="clearPath()">🧹 Effacer le Chemin</button>
                <button class="control-btn" onclick="addWaypoint()">📍 Ajouter Point de Passage</button>
                <button class="control-btn" onclick="centerOnKaamelott()">🏰 Centrer sur Kaamelott</button>
            </div>
            <div class="info-panel">
                <div id="map-status" class="status">Calculez la route optimale pour trouver l'entrée du labyrinthe!</div>
                <div class="legend">
                    <div class="legend-item">
                        <div class="legend-color" style="background: #32CD32;"></div>
                        <span>Kaamelott</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background: #FF6B6B;"></div>
                        <span>Entrée du Labyrinthe</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background: #FFD700;"></div>
                        <span>Points de Passage</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background: #4169E1; border: 2px dashed white;"></div>
                        <span>Route Calculée</span>
                    </div>
                </div>
            </div>
        </div>

        <div id="maze-container">
            <div id="maze"></div>
            <div class="controls">
                <!-- Los controles se generan dinámicamente en script.js -->
            </div>
            <div class="info-panel">
                <!-- El panel de información se genera dinámicamente en script.js -->
            </div>
        </div>
    </div>

    <!-- Scripts en el orden correcto -->
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <script src="https://unpkg.com/leaflet-routing-machine@3.2.12/dist/leaflet-routing-machine.js"></script>
    <script src="https://unpkg.com/three@0.157.0/build/three.min.js"></script>
    <script src="labyrinthe.js"></script>
    <script src="script.js"></script>
</body>

</html>
```

